<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: &quot;more like this&quot; search</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for solr_mlt {solrium}"><tr><td>solr_mlt {solrium}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>&quot;more like this&quot; search</h2>

<h3>Description</h3>

<p>Returns only more like this items
</p>


<h3>Usage</h3>

<pre>
solr_mlt(conn, name = NULL, params = NULL, body = NULL,
  callopts = list(), raw = FALSE, parsetype = "df", concat = ",",
  optimizeMaxRows = TRUE, minOptimizedRows = 50000L, progress = NULL,
  ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>conn</code></td>
<td>
<p>A solrium connection object, see <a href="SolrClient.html">SolrClient</a></p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p>Name of a collection or core. Or leave as <code>NULL</code> if not needed.</p>
</td></tr>
<tr valign="top"><td><code>params</code></td>
<td>
<p>(list) a named list of parameters, results in a GET reqeust
as long as no body parameters given</p>
</td></tr>
<tr valign="top"><td><code>body</code></td>
<td>
<p>(list) a named list of parameters, if given a POST request
will be performed</p>
</td></tr>
<tr valign="top"><td><code>callopts</code></td>
<td>
<p>Call options passed on to <a href="../../crul/html/HttpClient.html">crul::HttpClient</a></p>
</td></tr>
<tr valign="top"><td><code>raw</code></td>
<td>
<p>(logical) If TRUE, returns raw data in format specified by wt param</p>
</td></tr>
<tr valign="top"><td><code>parsetype</code></td>
<td>
<p>(character) One of 'list' or 'df'</p>
</td></tr>
<tr valign="top"><td><code>concat</code></td>
<td>
<p>(character) Character to concatenate elements of longer than length 1.
Note that this only works reliably when data format is json (wt='json'). The parsing
is more complicated in XML format, but you can do that on your own.</p>
</td></tr>
<tr valign="top"><td><code>optimizeMaxRows</code></td>
<td>
<p>(logical) If <code>TRUE</code>, then rows parameter will be
adjusted to the number of returned results by the same constraints.
It will only be applied if rows parameter is higher
than <code>minOptimizedRows</code>. Default: <code>TRUE</code></p>
</td></tr>
<tr valign="top"><td><code>minOptimizedRows</code></td>
<td>
<p>(numeric) used by <code>optimizedMaxRows</code> parameter,
the minimum optimized rows. Default: 50000</p>
</td></tr>
<tr valign="top"><td><code>progress</code></td>
<td>
<p>a function with logic for printing a progress
bar for an HTTP request, ultimately passed down to <span class="pkg">curl</span>. only supports
<code>httr::progress</code> for now. See the README for an example.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Further args to be combined into query</p>
</td></tr>
</table>


<h3>Value</h3>

<p>XML, JSON, a list, or data.frame
</p>


<h3>More like this parameters</h3>


<ul>
<li><p> q Query terms, defaults to '<em>:</em>', or everything.
</p>
</li>
<li><p> fq Filter query, this does not affect the search, only what gets returned
</p>
</li>
<li><p> mlt.count The number of similar documents to return for each result. Default is 5.
</p>
</li>
<li><p> mlt.fl The fields to use for similarity. NOTE: if possible these should have a stored
TermVector DEFAULT_FIELD_NAMES = new String[] &quot;contents&quot;
</p>
</li>
<li><p> mlt.mintf Minimum Term Frequency - the frequency below which terms will be ignored in
the source doc. DEFAULT_MIN_TERM_FREQ = 2
</p>
</li>
<li><p> mlt.mindf Minimum Document Frequency - the frequency at which words will be ignored which
do not occur in at least this many docs. DEFAULT_MIN_DOC_FREQ = 5
</p>
</li>
<li><p> mlt.minwl minimum word length below which words will be ignored.
DEFAULT_MIN_WORD_LENGTH = 0
</p>
</li>
<li><p> mlt.maxwl maximum word length above which words will be ignored.
DEFAULT_MAX_WORD_LENGTH = 0
</p>
</li>
<li><p> mlt.maxqt maximum number of query terms that will be included in any generated query.
DEFAULT_MAX_QUERY_TERMS = 25
</p>
</li>
<li><p> mlt.maxntp maximum number of tokens to parse in each example doc field that is not stored
with TermVector support. DEFAULT_MAX_NUM_TOKENS_PARSED = 5000
</p>
</li>
<li><p> mlt.boost (true/false) set if the query will be boosted by the interesting term relevance.
DEFAULT_BOOST = false
</p>
</li>
<li><p> mlt.qf Query fields and their boosts using the same format as that used in
DisMaxQParserPlugin. These fields must also be specified in mlt.fl.
</p>
</li>
<li><p> fl Fields to return. We force 'id' to be returned so that there is a unique identifier
with each record.
</p>
</li>
<li><p> wt (character) Data type returned, defaults to 'json'. One of json or xml. If json,
uses <code><a href="../../jsonlite/html/fromJSON.html">fromJSON</a></code> to parse. If xml, uses <code><a href="../../XML/html/xmlParse.html">xmlParse</a></code> to
parse. csv is only supported in <code><a href="solr_search.html">solr_search</a></code> and <code><a href="solr_all.html">solr_all</a></code>.
</p>
</li>
<li><p> start Record to start at, default to beginning.
</p>
</li>
<li><p> rows Number of records to return. Defaults to 10.
</p>
</li>
<li><p> key API key, if needed.
</p>
</li></ul>



<h3>References</h3>

<p>See <a href="http://wiki.apache.org/solr/MoreLikeThis">http://wiki.apache.org/solr/MoreLikeThis</a> for more
information.
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# connect
(conn &lt;- SolrClient$new(host = "api.plos.org", path = "search", port = NULL))

# more like this search
conn$mlt(params = list(q='*:*', mlt.count=2, mlt.fl='abstract', fl='score',
  fq="doc_type:full"))
conn$mlt(params = list(q='*:*', rows=2, mlt.fl='title', mlt.mindf=1,
  mlt.mintf=1, fl='alm_twitterCount'))
conn$mlt(params = list(q='title:"ecology" AND body:"cell"', mlt.fl='title',
  mlt.mindf=1, mlt.mintf=1, fl='counter_total_all', rows=5))
conn$mlt(params = list(q='ecology', mlt.fl='abstract', fl='title', rows=5))
solr_mlt(conn, params = list(q='ecology', mlt.fl='abstract',
  fl=c('score','eissn'), rows=5))
solr_mlt(conn, params = list(q='ecology', mlt.fl='abstract',
  fl=c('score','eissn'), rows=5, wt = "xml"))

# get raw data, and parse later if needed
out &lt;- solr_mlt(conn, params=list(q='ecology', mlt.fl='abstract', fl='title',
 rows=2), raw=TRUE)
solr_parse(out, "df")

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>solrium</em> version 1.0.2 <a href="00Index.html">Index</a>]</div>
</body></html>
