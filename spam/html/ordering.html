<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Extract the permutation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for ordering {spam}"><tr><td>ordering {spam}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Extract the permutation</h2>

<h3>Description</h3>

<p>Extract the (inverse) permutation used by the Cholesky
decomposition</p>


<h3>Usage</h3>

<pre>
ordering( x, inv=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>object of class <code>spam.chol.</code><em>method</em> returned by the function
<code>chol</code>.</p>
</td></tr>
<tr valign="top"><td><code>inv</code></td>
<td>
<p>Return the permutation (default) or inverse thereof.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recall that calculating a Cholesky factor from a sparse matrix
consists of finding a permutation first, then calculating the factors
of the permuted matrix. The ordering is important when working with
the factors themselves.<br />
</p>
<p>The ordering from a full/regular matrix is <code>1:n</code>.<br />
</p>
<p>Note that there exists many different algorithms to find
orderings.  
<br />
</p>
<p>See the examples, they speak more than 10 lines.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="chol.html">chol.spam</a></code>, <code><a href="solve.html">solve.spam</a></code>.
</p>


<h3>Examples</h3>

<pre>
# Construct a pd matrix S to work with (size n)
n &lt;- 100    # dimension
S &lt;- .25^abs(outer(1:n,1:n,"-"))
S &lt;- as.spam( S, eps=1e-4)
I &lt;- diag(n)  # Identity matrix

cholS &lt;- chol( S)
ord &lt;- ordering(cholS)
iord &lt;- ordering(cholS, inv=TRUE)

R &lt;- as.spam( cholS ) # R'R = P S P', with P=I[ord,],
  # a permutation matrix (rows permuted).
RtR &lt;- t(R) %*% R

# the following are equivalent:
as.spam( RtR -            S[ord,ord] )
as.spam( RtR[iord,iord] - S )
as.spam( t(R[,iord]) %*% R[,iord] - S )

# trivially:
as.spam( t(I[iord,]) - I[ord,])  # (P^-1)' = P  
as.spam( t(I[ord,]) - I[,ord])  # 
as.spam( I[iord,] - I[,ord])
as.spam( I[ord,]%*%S%*%I[,ord] - S[ord,ord] )
   # pre and post multiplication with P and P' is ordering
</pre>

<hr /><div style="text-align: center;">[Package <em>spam</em> version 2.2-1 <a href="00Index.html">Index</a>]</div>
</body></html>
