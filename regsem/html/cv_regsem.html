<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: The main function that runs multiple penalty values.</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for cv_regsem {regsem}"><tr><td>cv_regsem {regsem}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>The main function that runs multiple penalty values.</h2>

<h3>Description</h3>

<p>The main function that runs multiple penalty values.
</p>


<h3>Usage</h3>

<pre>
cv_regsem(model, n.lambda = 40, pars_pen = "regressions",
  metric = ifelse(fit.ret2 == "train", "BIC", "chisq"),
  mult.start = FALSE, multi.iter = 10, jump = 0.01,
  lambda.start = 0, alpha = 0.5, gamma = 3.7, type = "lasso",
  random.alpha = 0.5, fit.ret = c("rmsea", "BIC", "chisq"),
  fit.ret2 = "train", n.boot = 20, data = NULL,
  optMethod = "rsolnp", gradFun = "ram", hessFun = "none",
  test.cov = NULL, test.n.obs = NULL, prerun = FALSE,
  parallel = FALSE, ncore = 2, Start = "lavaan", subOpt = "nlminb",
  diff_par = NULL, LB = -Inf, UB = Inf, par.lim = c(-Inf, Inf),
  block = TRUE, full = TRUE, calc = "normal", max.iter = 2000,
  tol = 1e-05, round = 3, solver = FALSE, quasi = FALSE,
  solver.maxit = 5, alpha.inc = FALSE, step = 0.1,
  momentum = FALSE, step.ratio = FALSE, line.search = FALSE,
  nlminb.control = list(), warm.start = FALSE, missing = "listwise",
  verbose = TRUE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>model</code></td>
<td>
<p>Lavaan output object. This is a model that was previously
run with any of the lavaan main functions: cfa(), lavaan(), sem(),
or growth(). It also can be from the efaUnrotate() function from
the semTools package. Currently, the parts of the model which cannot
be handled in regsem is the use of multiple group models, missing
other than listwise, thresholds from categorical variable models,
the use of additional estimators other than
ML, most notably WLSMV for categorical variables. Note: the model
does not have to actually run (use do.fit=FALSE), converge etc...
regsem() uses the lavaan object as more of a parser and to get
sample covariance matrix.</p>
</td></tr>
<tr valign="top"><td><code>n.lambda</code></td>
<td>
<p>number of penalization values to test.</p>
</td></tr>
<tr valign="top"><td><code>pars_pen</code></td>
<td>
<p>Parameter indicators to penalize. There are multiple ways to specify.
The default is to penalize all regression parameters (&quot;regressions&quot;). Additionally,
one can specify all loadings (&quot;loadings&quot;), or both c(&quot;regressions&quot;,&quot;loadings&quot;).
Next, parameter labels can be assigned in the lavaan syntax and passed to pars_pen.
See the example.Finally, one can take the parameter numbers from the A or S matrices and pass these
directly. See extractMatrices(lav.object)$A.</p>
</td></tr>
<tr valign="top"><td><code>metric</code></td>
<td>
<p>Which fit index to use to choose a final model?
Note that it chooses the best fit that also achieves convergence
(conv=0).</p>
</td></tr>
<tr valign="top"><td><code>mult.start</code></td>
<td>
<p>Logical. Whether to use multi_optim() (TRUE) or
regsem() (FALSE).</p>
</td></tr>
<tr valign="top"><td><code>multi.iter</code></td>
<td>
<p>maximum number of random starts for multi_optim</p>
</td></tr>
<tr valign="top"><td><code>jump</code></td>
<td>
<p>Amount to increase penalization each iteration.</p>
</td></tr>
<tr valign="top"><td><code>lambda.start</code></td>
<td>
<p>What value to start the penalty at</p>
</td></tr>
<tr valign="top"><td><code>alpha</code></td>
<td>
<p>Mixture for elastic net. 1 = ridge, 0 = lasso</p>
</td></tr>
<tr valign="top"><td><code>gamma</code></td>
<td>
<p>Additional penalty for MCP and SCAD</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
<p>Penalty type. Options include &quot;none&quot;, &quot;lasso&quot;, &quot;ridge&quot;,
&quot;enet&quot; for the elastic net,
&quot;alasso&quot; for the adaptive lasso
and &quot;diff_lasso&quot;. diff_lasso penalizes the discrepency between
parameter estimates and some pre-specified values. The values
to take the deviation from are specified in diff_par. Two methods for
sparser results than lasso are the smooth clipped absolute deviation,
&quot;scad&quot;, and the minimum concave penalty, &quot;mcp&quot;. Last option is &quot;rlasso&quot;
which is the randomised lasso to be used for stability selection.</p>
</td></tr>
<tr valign="top"><td><code>random.alpha</code></td>
<td>
<p>Alpha parameter for randomised lasso. Has to be between
0 and 1, with a default of 0.5. Note this is only used for
&quot;rlasso&quot;, which pairs with stability selection.</p>
</td></tr>
<tr valign="top"><td><code>fit.ret</code></td>
<td>
<p>Fit indices to return.</p>
</td></tr>
<tr valign="top"><td><code>fit.ret2</code></td>
<td>
<p>Return fits using only dataset &quot;train&quot; or bootstrap &quot;boot&quot;? Have to
do 2 sample CV manually.</p>
</td></tr>
<tr valign="top"><td><code>n.boot</code></td>
<td>
<p>Number of bootstrap samples if fit.ret2=&quot;boot&quot;</p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
<p>Optional dataframe. Only required for missing=&quot;fiml&quot;.</p>
</td></tr>
<tr valign="top"><td><code>optMethod</code></td>
<td>
<p>Solver to use. Two main options for use: rsoolnp and coord_desc.
Although slightly slower, rsolnp works much better for complex models.
coord_desc uses gradient descent with soft thresholding for the type of
of penalty. Rsolnp is a nonlinear solver that doesn't rely on gradient
information. There is a similar type of solver also available for use,
slsqp from the nloptr package. coord_desc can also be used with hessian
information, either through the use of quasi=TRUE, or specifying a hess_fun.
However, this option is not recommended at this time.</p>
</td></tr>
<tr valign="top"><td><code>gradFun</code></td>
<td>
<p>Gradient function to use. Recommended to use &quot;ram&quot;,
which refers to the method specified in von Oertzen &amp; Brick (2014).
Only for use with optMethod=&quot;coord_desc&quot;.</p>
</td></tr>
<tr valign="top"><td><code>hessFun</code></td>
<td>
<p>hessian function to use. Currently not recommended.</p>
</td></tr>
<tr valign="top"><td><code>test.cov</code></td>
<td>
<p>Covariance matrix from test dataset. Necessary for CV=T</p>
</td></tr>
<tr valign="top"><td><code>test.n.obs</code></td>
<td>
<p>Number of observations in test set. Used when CV=T</p>
</td></tr>
<tr valign="top"><td><code>prerun</code></td>
<td>
<p>Logical. Use rsolnp to first optimize before passing to
gradient descent? Only for use with coord_desc</p>
</td></tr>
<tr valign="top"><td><code>parallel</code></td>
<td>
<p>Logical. whether to parallelize the processes running models for all
values of lambda.</p>
</td></tr>
<tr valign="top"><td><code>ncore</code></td>
<td>
<p>Number of cores to use when parallel=TRUE</p>
</td></tr>
<tr valign="top"><td><code>Start</code></td>
<td>
<p>type of starting values to use.</p>
</td></tr>
<tr valign="top"><td><code>subOpt</code></td>
<td>
<p>type of optimization to use in the optimx package.</p>
</td></tr>
<tr valign="top"><td><code>diff_par</code></td>
<td>
<p>parameter values to deviate from.</p>
</td></tr>
<tr valign="top"><td><code>LB</code></td>
<td>
<p>lower bound vector.</p>
</td></tr>
<tr valign="top"><td><code>UB</code></td>
<td>
<p>upper bound vector</p>
</td></tr>
<tr valign="top"><td><code>par.lim</code></td>
<td>
<p>Vector of minimum and maximum parameter estimates. Used to
stop optimization and move to new starting values if violated.</p>
</td></tr>
<tr valign="top"><td><code>block</code></td>
<td>
<p>Whether to use block coordinate descent</p>
</td></tr>
<tr valign="top"><td><code>full</code></td>
<td>
<p>Whether to do full gradient descent or block</p>
</td></tr>
<tr valign="top"><td><code>calc</code></td>
<td>
<p>Type of calc function to use with means or not. Not recommended
for use.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>Number of iterations for coordinate descent</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Tolerance for coordinate descent</p>
</td></tr>
<tr valign="top"><td><code>round</code></td>
<td>
<p>Number of digits to round results to</p>
</td></tr>
<tr valign="top"><td><code>solver</code></td>
<td>
<p>Whether to use solver for coord_desc</p>
</td></tr>
<tr valign="top"><td><code>quasi</code></td>
<td>
<p>Whether to use quasi-Newton</p>
</td></tr>
<tr valign="top"><td><code>solver.maxit</code></td>
<td>
<p>Max iterations for solver in coord_desc</p>
</td></tr>
<tr valign="top"><td><code>alpha.inc</code></td>
<td>
<p>Whether alpha should increase for coord_desc</p>
</td></tr>
<tr valign="top"><td><code>step</code></td>
<td>
<p>Step size</p>
</td></tr>
<tr valign="top"><td><code>momentum</code></td>
<td>
<p>Momentum for step sizes</p>
</td></tr>
<tr valign="top"><td><code>step.ratio</code></td>
<td>
<p>Ratio of step size between A and S. Logical</p>
</td></tr>
<tr valign="top"><td><code>line.search</code></td>
<td>
<p>Use line search for optimization. Default is no, use fixed step size</p>
</td></tr>
<tr valign="top"><td><code>nlminb.control</code></td>
<td>
<p>list of control values to pass to nlminb</p>
</td></tr>
<tr valign="top"><td><code>warm.start</code></td>
<td>
<p>Whether start values are based on previous iteration.
This is not recommended.</p>
</td></tr>
<tr valign="top"><td><code>missing</code></td>
<td>
<p>How to handle missing data. Current options are &quot;listwise&quot;
and &quot;fiml&quot;.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>Print progress bar?</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Any additional arguments to pass to regsem() or multi_optim().</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre>
## Not run: 
library(regsem)
vignette("overview",package="regsem")
# put variables on same scale for regsem
HS &lt;- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod &lt;- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
'
outt = cfa(mod, HS)
# increase to &gt; 25
cv.out = cv_regsem(outt,type="lasso", pars_pen=c(1:2,6:8),
          n.lambda=5,jump=0.01)
# check parameter numbers
extractMatrices(outt)["A"]
# equivalent to
mod &lt;- '
f =~ 1*x1 + l1*x2 + l2*x3 + l3*x4 + l4*x5 + l5*x6 + l6*x7 + l7*x8 + l8*x9
'
outt = cfa(mod,HS)
# increase to &gt; 25
cv.out = cv_regsem(outt, type="lasso", pars_pen=c("l1","l2","l6","l7","l8"),
         n.lambda=5,jump=0.01)
summary(cv.out)
plot(cv.out, show.minimum="BIC")

mod &lt;- '
f =~ x1 + x2 + x3 + x4 + x5 + x6
'
outt = cfa(mod, HS)
# can penalize all loadings
cv.out = cv_regsem(outt,type="lasso", pars_pen="loadings",
                  n.lambda=5,jump=0.01)

mod2 &lt;- '
f =~ x4+x5+x3
#x1 ~ x7 + x8 + x9 + x2
x1 ~ f
x2 ~ f
'
outt2 = cfa(mod2, HS)
extractMatrices(outt2)$A
# if no pars_pen specification, defaults to all
# regressions
cv.out = cv_regsem(outt2,type="lasso",
                  n.lambda=15,jump=0.03)
# check
cv.out$pars_pen

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>regsem</em> version 1.3.9 <a href="00Index.html">Index</a>]</div>
</body></html>
