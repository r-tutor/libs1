<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Asymmetric Laplace Distribution Family Functions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for alaplace {VGAM}"><tr><td>alaplace {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Asymmetric Laplace Distribution Family Functions </h2>

<h3>Description</h3>

<p>Maximum likelihood estimation of
the 1, 2 and 3-parameter asymmetric Laplace distributions (ALDs).
The 2-parameter ALD may,
with trepidation and lots of skill,
sometimes be used as an approximation of quantile regression.
</p>


<h3>Usage</h3>

<pre>
alaplace1(tau = NULL, llocation = "identitylink",
          ilocation = NULL, kappa = sqrt(tau/(1 - tau)), Scale.arg = 1,
          ishrinkage = 0.95, parallel.locat = TRUE  ~ 0, digt = 4,
          idf.mu = 3, zero = NULL, imethod = 1)

alaplace2(tau = NULL,  llocation = "identitylink", lscale = "loge",
          ilocation = NULL, iscale = NULL, kappa = sqrt(tau/(1 - tau)),
          ishrinkage = 0.95,
          parallel.locat =  TRUE ~ 0,
          parallel.scale = FALSE ~ 0,
          digt = 4, idf.mu = 3, imethod = 1, zero = "scale")

alaplace3(llocation = "identitylink", lscale = "loge", lkappa = "loge",
          ilocation = NULL, iscale = NULL, ikappa = 1,
          imethod = 1, zero = c("scale", "kappa"))
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>tau, kappa</code></td>
<td>
<p> Numeric vectors with
<i>0 &lt; tau &lt; 1</i> and <i>kappa &gt;0</i>.
Most users will only specify <code>tau</code> since the estimated
location parameter corresponds to the <i>tau</i>th
regression quantile, which is easier to understand.
See below for details.
</p>
</td></tr>
<tr valign="top"><td><code>llocation, lscale, lkappa</code></td>
<td>
<p> Character.
Parameter link functions for
location parameter <i>xi</i>,
scale parameter <i>sigma</i>,
asymmetry parameter <i>kappa</i>.
See <code><a href="Links.html">Links</a></code> for more choices.
For example, the argument <code>llocation</code> can help handle
count data by restricting the quantiles to be positive
(use <code>llocation = "loge"</code>).
However, <code>llocation</code> is best left alone since the theory
only works properly with the identity link.
</p>
</td></tr>
<tr valign="top"><td><code>ilocation, iscale, ikappa</code></td>
<td>

<p>Optional initial values.
If given, it must be numeric and values are recycled to the
appropriate length.
The default is to choose the value internally.
</p>
</td></tr>
<tr valign="top"><td><code>parallel.locat, parallel.scale</code></td>
<td>

<p>See the <code>parallel</code> argument of <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code>.
These arguments apply to the location and scale parameters.
It generally only makes sense for the scale parameters
to be equal, hence set <code>parallel.scale = TRUE</code>.
Note that
assigning <code>parallel.locat</code> the value <code>TRUE</code> circumvents the
seriously embarrassing quantile crossing problem because all
constraint matrices except for the intercept correspond to a
parallelism assumption.
</p>
</td></tr>
</table>









<table summary="R argblock">
<tr valign="top"><td><code>imethod</code></td>
<td>

<p>Initialization method.
Either the value 1, 2, 3 or 4.
</p>
</td></tr>
<tr valign="top"><td><code>idf.mu</code></td>
<td>

<p>Degrees of freedom for the cubic smoothing spline fit applied to
get an initial estimate of the location parameter.
See <code><a href="vsmooth.spline.html">vsmooth.spline</a></code>.
Used only when <code>imethod = 3</code>.
</p>
</td></tr>
<tr valign="top"><td><code>ishrinkage</code></td>
<td>

<p>How much shrinkage is used when initializing <i>xi</i>.
The value must be between 0 and 1 inclusive, and
a value of 0 means the individual response values are used,
and a value of 1 means the median or mean is used.
This argument is used only when <code>imethod = 4</code>.
See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information.
</p>
</td></tr>
<tr valign="top"><td><code>Scale.arg</code></td>
<td>

<p>The value of the scale parameter <i>sigma</i>.
This argument may be used to compute quantiles at
different <i>tau</i> values from an existing fitted
<code>alaplace2()</code> model (practical only if it has a
single value).
If the model has <code>parallel.locat = TRUE</code> then
only the intercept need be estimated; use an offset.
See below for an example.
</p>


</td></tr>
<tr valign="top"><td><code>digt </code></td>
<td>

<p>Passed into <code><a href="../../base/html/Round.html">Round</a></code> as the <code>digits</code> argument
for the <code>tau</code> values;
used cosmetically for labelling.
</p>
</td></tr>
<tr valign="top"><td><code>zero</code></td>
<td>

<p>See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information.
Where possible,
the default is to model all the <i>sigma</i>
and <i>kappa</i> as an intercept-only term.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These <span class="pkg">VGAM</span> family functions implement one variant of asymmetric
Laplace distributions (ALDs) suitable for quantile regression.
Kotz et al. (2001) call it <em>the</em> ALD.
Its density function is
</p>
<p style="text-align: center;"><i>
     f(y;xi,sigma,kappa) =  (sqrt(2)/sigma) * (kappa/(1+ &kappa;^2)) *
         exp( -(sqrt(2) / (sigma * kappa)) * |y-xi| ) </i></p>

<p>for <i>y &lt;=  xi</i>, and
</p>
<p style="text-align: center;"><i>
     f(y;xi,sigma,kappa) =  (sqrt(2)/sigma) * (kappa/(1+ &kappa;^2)) * exp( -
     (sqrt(2) * kappa / sigma) * |y-xi| ) </i></p>

<p>for <i>y &gt; xi</i>.
Here, the ranges are
for all real <i>y</i> and <i>xi</i>, positive <i>sigma</i>
and positive <i>kappa</i>.
The special case <i>kappa = 1</i> corresponds to the
(symmetric) Laplace distribution of Kotz et al. (2001).
The mean is <i>xi +
     sigma * (1/kappa - kappa) / sqrt(2)</i>
and the variance is
<i>sigma^2 * (1 +
     kappa^4) / (2 * kappa^2)</i>.
The enumeration of the linear/additive predictors used for
<code>alaplace2()</code> is
the first location parameter followed by the first scale parameter,
then the second location parameter followed by the
second scale parameter, etc.
For <code>alaplace3()</code>, only a vector response is handled
and the last (third) linear/additive predictor is for
the asymmetry parameter.
</p>
<p>It is known that the maximum likelihood estimate of the
location parameter <i>xi</i> corresponds to the regression
quantile estimate of the classical quantile regression approach of
Koenker and Bassett (1978). An important property of the ALD is that
<i>P(Y &lt;=   xi) = tau</i> where
<i>tau = kappa^2 / (1 + kappa^2)</i>
so that
<i>kappa = sqrt(tau / (1-tau))</i>.
Thus <code>alaplace2()</code> might be used as an alternative to <code>rq</code>
in the <span class="pkg">quantreg</span> package, although scoring is really
an unsuitable algorithm for estimation here.
</p>
<p>Both <code>alaplace1()</code> and <code>alaplace2()</code> can handle
multiple responses, and the number of linear/additive
predictors is dictated by the length of <code>tau</code> or
<code>kappa</code>.  The functions <code>alaplace1()</code>
and <code>alaplace2()</code> can also
handle multiple responses (i.e., a matrix response)
but only with a <em>single-valued</em> <code>tau</code> or <code>kappa</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> (see <code><a href="vglmff-class.html">vglmff-class</a></code>).
The object is used by modelling functions such as <code><a href="vglm.html">vglm</a></code>
and <code><a href="vgam.html">vgam</a></code>.
</p>
<p>In the <code>extra</code> slot of the fitted object are some list
components which are useful, e.g., the sample proportion of
values which are less than the fitted quantile curves.
</p>


<h3>Warning</h3>

<p>These functions are <em>experimental</em> and especially subject to
change or withdrawal.
The usual MLE regularity conditions do <em>not</em> hold for this
distribution so that misleading inferences may result,
e.g., in the <code>summary</code> and <code>vcov</code> of the object.
</p>
<p>Care is needed with <code>tau</code> values which are too small, e.g.,
for count data with <code>llocation = "loge"</code> and if the sample
proportion of zeros is greater than <code>tau</code>.
</p>


<h3>Note</h3>







<p>These <span class="pkg">VGAM</span> family functions use Fisher scoring.
Convergence may be slow and half-stepping is usual
(although one can use <code>trace = TRUE</code> to see which
is the best model and then use <code>maxit</code> to choose
that model)
due to the regularity conditions not holding.
Often the iterations slowly crawl towards the solution so
monitoring the convergence (set <code>trace = TRUE</code>) is highly
recommended.
</p>
<p>For large data sets it is a very good idea to keep the length of
<code>tau</code>/<code>kappa</code> low to avoid large memory requirements.
Then
for <code>parallel.locat = FALSE</code> one can repeatedly fit a model with
<code>alaplace1()</code> with one <i>tau</i> at a time;
and
for <code>parallel.locat = TRUE</code> one can refit a model with
<code>alaplace1()</code> with one <i>tau</i> at a time but
using offsets and an intercept-only model.
</p>
<p>A second method for solving the noncrossing quantile problem is
illustrated below in Example 3.
This is called the <em>accumulative quantile method</em> (AQM)
and details are in Yee (2015).
It does not make the strong parallelism assumption.
</p>
<p>The functions <code>alaplace2()</code> and <code><a href="laplace.html">laplace</a></code>
differ slightly in terms of the parameterizations.
</p>


<h3>Author(s)</h3>

<p> Thomas W. Yee </p>


<h3>References</h3>

<p>Koenker, R. and Bassett, G. (1978)
Regression quantiles.
<em>Econometrica</em>,
<b>46</b>, 33&ndash;50.
</p>
<p>Kotz, S., Kozubowski, T. J. and Podgorski, K. (2001)
<em>The Laplace distribution and generalizations:
a revisit with applications to communications,
economics, engineering, and finance</em>,
Boston: Birkhauser.
</p>





<h3>See Also</h3>

<p><code><a href="alaplaceUC.html">ralap</a></code>,
<code><a href="laplace.html">laplace</a></code>,
<code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code>,
<code><a href="lms.bcn.html">lms.bcn</a></code>,
<code><a href="amlnormal.html">amlnormal</a></code>,
<code><a href="sc.studentt2.html">sc.studentt2</a></code>,
<code><a href="simulate.vlm.html">simulate.vlm</a></code>.
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Example 1: quantile regression with smoothing splines
set.seed(123); adata &lt;- data.frame(x2 = sort(runif(n &lt;- 500)))
mymu &lt;- function(x) exp(-2 + 6*sin(2*x-0.2) / (x+0.5)^2)
adata &lt;- transform(adata, y = rpois(n, lambda = mymu(x2)))
mytau &lt;- c(0.25, 0.75); mydof &lt;- 4

fit &lt;- vgam(y ~ s(x2, df = mydof), data = adata, trace = TRUE, maxit = 900,
            alaplace2(tau = mytau, llocat = "loge",
                      parallel.locat = FALSE))
fitp &lt;- vgam(y ~ s(x2, df = mydof), data = adata, trace = TRUE, maxit = 900,
             alaplace2(tau = mytau, llocat = "loge", parallel.locat = TRUE))

par(las = 1); mylwd &lt;- 1.5
with(adata, plot(x2, jitter(y, factor = 0.5), col = "orange",
                 main = "Example 1; green: parallel.locat = TRUE",
                 ylab = "y", pch = "o", cex = 0.75))
with(adata, matlines(x2, fitted(fit ), col = "blue",
                     lty = "solid", lwd = mylwd))
with(adata, matlines(x2, fitted(fitp), col = "green",
                     lty = "solid", lwd = mylwd))
finexgrid &lt;- seq(0, 1, len = 1001)
for (ii in 1:length(mytau))
  lines(finexgrid, qpois(p = mytau[ii], lambda = mymu(finexgrid)),
        col = "blue", lwd = mylwd)
fit@extra  # Contains useful information


# Example 2: regression quantile at a new tau value from an existing fit
# Nb. regression splines are used here since it is easier.
fitp2 &lt;- vglm(y ~ sm.bs(x2, df = mydof), data = adata, trace = TRUE,
              alaplace1(tau = mytau, llocation = "loge",
                        parallel.locat = TRUE))

newtau &lt;- 0.5  # Want to refit the model with this tau value
fitp3 &lt;- vglm(y ~ 1 + offset(predict(fitp2)[, 1]),
              alaplace1(tau = newtau, llocation = "loge"), data = adata)
with(adata, plot(x2, jitter(y, factor = 0.5), col = "orange",
               pch = "o", cex = 0.75, ylab = "y",
               main = "Example 2; parallel.locat = TRUE"))
with(adata, matlines(x2, fitted(fitp2), col = "blue",
                     lty = 1, lwd = mylwd))
with(adata, matlines(x2, fitted(fitp3), col = "black",
                     lty = 1, lwd = mylwd))


# Example 3: noncrossing regression quantiles using a trick: obtain
# successive solutions which are added to previous solutions; use a log
# link to ensure an increasing quantiles at any value of x.

mytau &lt;- seq(0.2, 0.9, by = 0.1)
answer &lt;- matrix(0, nrow(adata), length(mytau))  # Stores the quantiles
adata &lt;- transform(adata, offsety = y*0)
usetau &lt;- mytau
for (ii in 1:length(mytau)) {
# cat("\n\nii  = ", ii, "\n")
  adata &lt;- transform(adata, usey = y-offsety)
  iloc &lt;- ifelse(ii == 1, with(adata, median(y)), 1.0)  # Well-chosen!
  mydf &lt;- ifelse(ii == 1, 5, 3)  # Maybe less smoothing will help
# lloc &lt;- ifelse(ii == 1, "loge", "loge")  # 2nd value must be "loge"
  fit3 &lt;- vglm(usey ~ sm.ns(x2, df = mydf), data = adata, trace = TRUE,
               alaplace2(tau = usetau[ii], lloc = "loge", iloc = iloc))
  answer[, ii] &lt;- (if(ii == 1) 0 else answer[, ii-1]) + fitted(fit3)
  adata &lt;- transform(adata, offsety = answer[, ii])
}

# Plot the results.
with(adata, plot(x2, y, col = "blue",
     main = paste("Noncrossing and nonparallel; tau  = ",
                paste(mytau, collapse = ", "))))
with(adata, matlines(x2, answer, col = "orange", lty = 1))

# Zoom in near the origin.
with(adata, plot(x2, y, col = "blue", xlim = c(0, 0.2), ylim = 0:1,
     main = paste("Noncrossing and nonparallel; tau  = ",
                paste(mytau, collapse = ", "))))
with(adata, matlines(x2, answer, col = "orange", lty = 1))

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-6 <a href="00Index.html">Index</a>]</div>
</body></html>
