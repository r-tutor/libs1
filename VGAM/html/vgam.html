<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Fitting Vector Generalized Additive Models</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for vgam {VGAM}"><tr><td>vgam {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Fitting Vector Generalized Additive Models </h2>

<h3>Description</h3>

<p>Fit a vector generalized additive model (VGAM).
Both 1st-generation VGAMs (based on backfitting) and
2nd-generation VGAMs (based on P-splines, with automatic
smoothing parameter selection) are implemented.
This is a large class
of models that includes generalized additive models (GAMs) and vector
generalized linear models (VGLMs) as special cases.
</p>


<h3>Usage</h3>

<pre>
vgam(formula, family = stop("argument 'family' needs to be assigned"),
     data = list(), weights = NULL, subset = NULL,
     na.action = na.fail, etastart = NULL, mustart = NULL,
     coefstart = NULL, control = vgam.control(...), offset = NULL,
     method = "vgam.fit", model = FALSE, x.arg = TRUE, y.arg = TRUE,
     contrasts = NULL, constraints = NULL,
     extra = list(), form2 = NULL, qr.arg = FALSE, smart = TRUE, ...)
</pre>


<h3>Arguments</h3>


<table summary="R argblock">
<tr valign="top"><td><code>formula</code></td>
<td>

<p>a symbolic description of the model to be fit.
The RHS of the formula is applied to each linear/additive predictor,
and should include at least one
<code><a href="sm.os.html">sm.os</a></code> term
or <code><a href="sm.ps.html">sm.ps</a></code> term
or <code><a href="s.html">s</a></code> term.
Mixing both together is not allowed.
Different variables in each linear/additive predictor
can be chosen by specifying constraint matrices.
</p>
</td></tr>
<tr valign="top"><td><code>family</code></td>
<td>

<p>Same as for <code><a href="vglm.html">vglm</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>

<p>an optional data frame containing the variables in the model.
By default the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>vgam</code> is called.
</p>
</td></tr>
<tr valign="top"><td><code>weights, subset, na.action</code></td>
<td>

<p>Same as for <code><a href="vglm.html">vglm</a></code>.
Note that <code>subset</code> may be unreliable and to get around
this problem it is best to use <code><a href="../../base/html/subset.html">subset</a></code> to create
a new smaller data frame and feed in the smaller data frame.
See below for an example.
This is a bug that needs fixing.
</p>
</td></tr>
<tr valign="top"><td><code>etastart, mustart, coefstart</code></td>
<td>

<p>Same as for <code><a href="vglm.html">vglm</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>control</code></td>
<td>

<p>a list of parameters for controlling the fitting process.
See <code><a href="vgam.control.html">vgam.control</a></code> for details.
</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>

<p>the method to be used in fitting the model.
The default (and presently only) method <code>vgam.fit</code>
uses iteratively reweighted least squares (IRLS).
</p>
</td></tr>
<tr valign="top"><td><code>constraints, model, offset</code></td>
<td>

<p>Same as for <code><a href="vglm.html">vglm</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>x.arg, y.arg</code></td>
<td>

<p>logical values indicating whether the model matrix and response
vector/matrix used in the fitting process should be assigned in the
<code>x</code> and <code>y</code> slots.  Note the model matrix is the LM model
matrix; to get the VGAM model matrix type <code>model.matrix(vgamfit)</code>
where <code>vgamfit</code> is a <code>vgam</code> object.
</p>
</td></tr>
<tr valign="top"><td><code>contrasts, extra, form2, qr.arg, smart</code></td>
<td>

<p>Same as for <code><a href="vglm.html">vglm</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>

<p>further arguments passed into <code><a href="vgam.control.html">vgam.control</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A vector generalized additive model (VGAM) is loosely defined
as a statistical model that is a function of <i>M</i> additive predictors.
The central formula is given by
</p>
<p style="text-align: center;"><i>
         eta_j = sum_{k=1}^p f_{(j)k}(x_k)</i></p>

<p>where <i>x_k</i> is the <i>k</i>th explanatory variable
(almost always <i>x_1=1</i> for the intercept term),
and
<i>f_{(j)k}</i> are smooth functions of <i>x_k</i> that are estimated
by smoothers.
The first term in the summation is just the intercept.
Currently
two types of smoothers are
implemented:
<code><a href="s.html">s</a></code> represents
the older and more traditional one, called a
<em>vector (cubic smoothing spline) smoother</em> and is
based on Yee and Wild (1996);
it is more similar to the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> package <span class="pkg">gam</span>.
The newer one is represented by
<code><a href="sm.os.html">sm.os</a></code> and
<code><a href="sm.ps.html">sm.ps</a></code>, and these are
based on O-splines and P-splines&mdash;they allow automatic
smoothing parameter selection; it is more similar
to the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> package <span class="pkg">mgcv</span>.
</p>
<p>In the above, <i>j=1,&hellip;,M</i> where <i>M</i> is finite.
If all the functions are constrained to be linear then
the resulting model is a vector generalized linear model
(VGLM).  VGLMs are best fitted with <code><a href="vglm.html">vglm</a></code>.
</p>
<p>Vector (cubic smoothing spline) smoothers are represented
by <code>s()</code> (see <code><a href="s.html">s</a></code>). Local
regression via <code>lo()</code> is <em>not</em> supported. The
results of <code>vgam</code> will differ from the <code>gam()</code>
(in the <span class="pkg">gam</span>) because <code>vgam()</code> uses a different
knot selection algorithm. In general, fewer knots are
chosen because the computation becomes expensive when
the number of additive predictors <i>M</i> is large.
</p>
<p>Second-generation VGAMs are based on the
O-splines and P-splines.
The latter is due to Eilers and Marx (1996).
Backfitting is not required, and estimation is performed using IRLS.
The function <code><a href="sm.os.html">sm.os</a></code> represents a <em>smart</em>
implementation of O-splines.
The function <code><a href="sm.ps.html">sm.ps</a></code> represents a <em>smart</em>
implementation of P-splines.
Written G2-VGAMs or P-VGAMs, this methodology should not be used
unless the sample size is reasonably large.
Usually an UBRE predictive criterion is optimized
(at each IRLS iteration)
because the
scale parameter for VGAMs is usually assumed to be known.
This search for optimal smoothing parameters does not always converge,
and neither is it totally reliable.
G2-VGAMs implicitly set <code>criterion = "coefficients"</code> so that
convergence occurs when the change in the regression coefficients
between 2 IRLS iterations is sufficiently small.
Otherwise the search for the optimal smoothing parameters might
cause the log-likelihood to decrease between 2 IRLS iterations.
Currently <em>outer iteration</em> is implemented,
by default,
rather than <em>performance iteration</em> because the latter
is more easy to converge to a local solution; see
Wood (2004) for details.
One can use <em>performance iteration</em>
by setting <code>Maxit.outer = 1</code> in
<code><a href="vgam.control.html">vgam.control</a></code>.
</p>


<p>The underlying algorithm of VGAMs is IRLS.
First-generation VGAMs (called G1-VGAMs)
are estimated by modified vector backfitting
using vector splines. O-splines are used as the basis functions
for the vector (smoothing) splines, which are a lower dimensional
version of natural B-splines.
The function <code>vgam.fit()</code> actually does the
work.  The smoothing code is based on F. O'Sullivan's
BART code.
</p>


<p>A closely related methodology based on VGAMs called
<em>constrained additive ordination</em> (CAO) first forms
a linear combination of the explanatory variables (called
<em>latent variables</em>) and then fits a GAM to these.
This is implemented in the function <code><a href="cao.html">cao</a></code>
for a very limited choice of family functions.
</p>


<h3>Value</h3>

<p>For G1-VGAMs and G2-VGAMs, an object of class
<code>"vgam"</code> or
<code>"pvgam"</code>
respectively
(see <code><a href="vgam-class.html">vgam-class</a></code>
and <code><a href="notdocumentedyet.html">pvgam-class</a></code>
for further information).
</p>


<h3>WARNING</h3>

<p>For G1-VGAMs,
currently <code>vgam</code> can only handle constraint matrices <code>cmat</code>,
say, such that <code>crossprod(cmat)</code> is diagonal.
It can be detected by <code><a href="is.buggy.html">is.buggy</a></code>.
VGAMs with constraint matrices that have non-orthogonal columns should
be fitted with
<code><a href="sm.os.html">sm.os</a></code> or
<code><a href="sm.ps.html">sm.ps</a></code> terms
instead of <code><a href="s.html">s</a></code>.
</p>

<p>See warnings in <code><a href="vglm.control.html">vglm.control</a></code>.
</p>


<h3>Note</h3>

<p>This function can fit a wide variety of statistical models. Some of
these are harder to fit than others because of inherent numerical
difficulties associated with some of them. Successful model fitting
benefits from cumulative experience. Varying the values of arguments
in the <span class="pkg">VGAM</span> family function itself is a good first step if
difficulties arise, especially if initial values can be inputted.
A second, more general step, is to vary the values of arguments in
<code><a href="vgam.control.html">vgam.control</a></code>.
A third step is to make use of arguments such as <code>etastart</code>,
<code>coefstart</code> and <code>mustart</code>.
</p>
<p>Some <span class="pkg">VGAM</span> family functions end in <code>"ff"</code>
to avoid interference with other functions, e.g.,
<code><a href="binomialff.html">binomialff</a></code>, <code><a href="poissonff.html">poissonff</a></code>.
This is because <span class="pkg">VGAM</span> family functions are incompatible with
<code><a href="../../stats/html/glm.html">glm</a></code> (and also <code><a href="../../gam/html/gam.html">gam</a></code>
in the <span class="pkg">gam</span> library and <code><a href="../../mgcv/html/gam.html">gam</a></code>
in the <span class="pkg">mgcv</span> library).
</p>


<p>The smart prediction (<code><a href="smartpred.html">smartpred</a></code>) library
is packed with the <span class="pkg">VGAM</span> library.
</p>
<p>The theory behind the scaling parameter is currently being
made more rigorous, but it it should give the same value
as the scale parameter for GLMs.
</p>


<h3>Author(s)</h3>

<p> Thomas W. Yee </p>


<h3>References</h3>

<p>Wood, S. N. (2004).
Stable and efficient multiple smoothing parameter estimation
for generalized additive models.
<em>J. Amer. Statist. Assoc.</em>, <b>99</b>(467): 673&ndash;686.
</p>
<p>Yee, T. W. and Wild, C. J. (1996)
Vector generalized additive models.
<em>Journal of the Royal Statistical Society, Series B, Methodological</em>,
<b>58</b>, 481&ndash;493.
</p>
<p>Yee, T. W. (2008)
The <code>VGAM</code> Package.
<em>R News</em>, <b>8</b>, 28&ndash;39.
</p>
<p>Yee, T. W. (2015)
Vector Generalized Linear and Additive Models:
With an Implementation in R.
New York, USA: <em>Springer</em>.
</p>
<p>Yee, T. W. (2016).
Comments on &ldquo;Smoothing parameter and model selection for
general smooth models&rdquo;
by Wood, S. N. and Pya, N. and Safken, N.,
<em>J. Amer. Statist. Assoc.</em>, <b>110</b>(516).
</p>













<h3>See Also</h3>

<p><code><a href="is.buggy.html">is.buggy</a></code>,
<code><a href="vgam.control.html">vgam.control</a></code>,
<code><a href="vgam-class.html">vgam-class</a></code>,
<code><a href="vglmff-class.html">vglmff-class</a></code>,
<code><a href="plotvgam.html">plotvgam</a></code>,
<code><a href="summaryvgam.html">summaryvgam</a></code>,
<code><a href="summarypvgam.html">summarypvgam</a></code>,
<code><a href="sm.os.html">sm.os</a></code>,
<code><a href="sm.ps.html">sm.ps</a></code>,
<code><a href="s.html">s</a></code>,
<code><a href="../../mgcv/html/magic.html">magic</a></code>.
<code><a href="vglm.html">vglm</a></code>,
<code><a href="vsmooth.spline.html">vsmooth.spline</a></code>,
<code><a href="cao.html">cao</a></code>.
</p>


<h3>Examples</h3>

<pre># Nonparametric proportional odds model
pneumo &lt;- transform(pneumo, let = log(exposure.time))
vgam(cbind(normal, mild, severe) ~ s(let),
     cumulative(parallel = TRUE), data = pneumo, trace = TRUE)

# Nonparametric logistic regression
hfit &lt;- vgam(agaaus ~ s(altitude, df = 2), binomialff, data = hunua)
## Not run:  plot(hfit, se = TRUE) 
phfit &lt;- predict(hfit, type = "terms", raw = TRUE, se = TRUE)
names(phfit)
head(phfit$fitted)
head(phfit$se.fit)
phfit$df
phfit$sigma

# Fit two species simultaneously
hfit2 &lt;- vgam(cbind(agaaus, kniexc) ~ s(altitude, df = c(2, 3)),
              binomialff(multiple.responses = TRUE), data = hunua)
coef(hfit2, matrix = TRUE)  # Not really interpretable
## Not run: 
plot(hfit2, se = TRUE, overlay = TRUE, lcol = 3:4, scol = 3:4)
ooo &lt;- with(hunua, order(altitude))
with(hunua, matplot(altitude[ooo], fitted(hfit2)[ooo,], ylim = c(0, 0.8),
     xlab = "Altitude (m)", ylab = "Probability of presence", las = 1,
     main = "Two plant species' response curves", type = "l", lwd = 2))
with(hunua, rug(altitude))

## End(Not run)

# The 'subset' argument does not work here. Use subset() instead.
set.seed(1)
zdata &lt;- data.frame(x2 = runif(nn &lt;- 500))
zdata &lt;- transform(zdata, y = rbinom(nn, 1, 0.5))
zdata &lt;- transform(zdata, subS = runif(nn) &lt; 0.7)
sub.zdata &lt;- subset(zdata, subS)  # Use this instead
if (FALSE)
  fit4a &lt;- vgam(cbind(y, y) ~ s(x2, df = 2),
                binomialff(multiple.responses = TRUE),
                data = zdata, subset = subS)  # This fails!!!
fit4b &lt;- vgam(cbind(y, y) ~ s(x2, df = 2),
              binomialff(multiple.responses = TRUE),
              data = sub.zdata)  # This succeeds!!!
fit4c &lt;- vgam(cbind(y, y) ~ sm.os(x2),
              binomialff(multiple.responses = TRUE),
              data = sub.zdata)  # This succeeds!!!
## Not run: par(mfrow = c(2, 2))
plot(fit4b, se = TRUE, shade = TRUE, shcol = "pink")
plot(fit4c, se = TRUE, shade = TRUE, shcol = "pink")

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-6 <a href="00Index.html">Index</a>]</div>
</body></html>
