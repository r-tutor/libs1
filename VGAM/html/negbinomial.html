<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Negative Binomial Distribution Family Function</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for negbinomial {VGAM}"><tr><td>negbinomial {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Negative Binomial Distribution Family Function </h2>

<h3>Description</h3>

<p>Maximum likelihood estimation of the two parameters of a negative
binomial distribution.
</p>


<h3>Usage</h3>

<pre>
negbinomial(zero = -2, parallel = FALSE, deviance.arg = FALSE,
            type.fitted = c("mean", "quantiles"),
            percentiles = c(25, 50, 75),
            mds.min = 1e-3, nsimEIM = 500, cutoff.prob = 0.999,
            eps.trig = 1e-7, max.support = 4000, max.chunk.MB = 30,
            lmu = "loge", lsize = "loge",
            imethod = 1, imu = NULL, iprobs.y = NULL,
            gprobs.y = ppoints(6), isize = NULL,
            gsize.mux = exp(c(-30, -20, -15, -10, -6:3)))
polya(zero = "size", type.fitted = c("mean", "prob"),
      mds.min = 1e-3, nsimEIM = 500, cutoff.prob = 0.999,
      eps.trig = 1e-7, max.support = 4000, max.chunk.MB = 30,
      lprob = "logit", lsize = "loge", imethod = 1, iprob = NULL,
      iprobs.y = NULL, gprobs.y = ppoints(6), isize = NULL,
      gsize.mux = exp(c(-30, -20, -15, -10, -6:3)), imunb = NULL)
polyaR(zero = "size", type.fitted = c("mean", "prob"),
       mds.min = 1e-3, nsimEIM = 500,  cutoff.prob = 0.999,
       eps.trig = 1e-7, max.support = 4000, max.chunk.MB = 30,
       lsize = "loge", lprob = "logit", imethod = 1, iprob = NULL,
       iprobs.y = NULL, gprobs.y = ppoints(6), isize = NULL,
       gsize.mux = exp(c(-30, -20, -15, -10, -6:3)), imunb = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>lmu, lsize, lprob</code></td>
<td>

<p>Link functions applied to the <i>mu</i>, <i>k</i>
and <i>p</i>  parameters.
See <code><a href="Links.html">Links</a></code> for more choices.
Note that the <i>mu</i>, <i>k</i>
and <i>p</i>  parameters are the <code>mu</code>,
<code>size</code> and <code>prob</code> arguments of
<code><a href="../../stats/html/NegBinomial.html">rnbinom</a></code> respectively.
Common alternatives for <code>lsize</code> are
<code><a href="loge.html">negloge</a></code> and
<code><a href="reciprocal.html">reciprocal</a></code>, and
<code><a href="loglog.html">loglog</a></code> (if <i>k &gt; 1</i>).
</p>
</td></tr>
<tr valign="top"><td><code>imu, imunb, isize, iprob</code></td>
<td>

<p>Optional initial values for the mean and <i>k</i> and <i>p</i>.
For <i>k</i>, if failure to converge occurs then try different values
(and/or use <code>imethod</code>).
For a <i>S</i>-column response, <code>isize</code> can be of length <i>S</i>.
A value <code>NULL</code> means an initial value for each response is
computed internally using a gridsearch based on <code>gsize.mux</code>.
The last argument is ignored if used within <code><a href="cqo.html">cqo</a></code>; see
the <code>iKvector</code> argument of <code><a href="qrrvglm.control.html">qrrvglm.control</a></code> instead.
In the future <code>isize</code> and <code>iprob</code> might be depreciated.
</p>
</td></tr>
<tr valign="top"><td><code>nsimEIM</code></td>
<td>

<p>This argument is used
for computing the diagonal element of the
<em>expected information matrix</em> (EIM) corresponding to <i>k</i>
based on the <em>simulated Fisher scoring</em> (SFS) algorithm.
See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information
and the notes below.
SFS is one of two algorithms for computing the EIM elements
(so that both algorithms may be used on a given data set).
SFS is faster than the exact method when <code>Qmax</code> is large.
</p>
</td></tr>
<tr valign="top"><td><code>cutoff.prob</code></td>
<td>

<p>Fed into the <code>p</code> argument
of <code><a href="../../stats/html/NegBinomial.html">qnbinom</a></code>
in order to obtain an upper limit for the approximate
support of the distribution, called <code>Qmax</code>, say.
Similarly, the value <code>1-p</code> is
fed into the <code>p</code> argument
of <code><a href="../../stats/html/NegBinomial.html">qnbinom</a></code>
in order to obtain a lower limit for the approximate
support of the distribution, called <code>Qmin</code>, say.
Hence the approximate support is <code>Qmin:Qmax</code>.
This argument should be
a numeric and close to 1 but never exactly 1.
Used to specify how many terms of the infinite series
for computing the second diagonal element of the
EIM are actually used.
The closer this argument is to 1, the more accurate the
standard errors of the regression coefficients will be.
If this argument is too small, convergence will take longer.
</p>





</td></tr>
<tr valign="top"><td><code>max.chunk.MB, max.support</code></td>
<td>

<p><code>max.support</code> is used to describe the eligibility of
individual observations
to have their EIM computed by the <em>exact method</em>.
Here, we are concerned about
computing the EIM wrt <i>k</i>.
The exact method algorithm operates separately on each response
variable,
and it constructs a large matrix provided that the number of columns
is less than <code>max.support</code>.
If so, then the computations are done in chunks, so
that no more than about <code>max.chunk.MB</code> megabytes
of memory is used at a time (actually, it is proportional to this amount).
Regarding eligibility of this algorithm, each observation must
have the length of the vector, starting from
the <code>1-cutoff.prob</code> quantile
and finishing up at the <code>cutoff.prob</code> quantile,
less than <code>max.support</code>
(as its approximate support).
If you have abundant memory then you might try setting
<code>max.chunk.MB = Inf</code>, but then the computations might take
a very long time.
Setting <code>max.chunk.MB = 0</code> or <code>max.support = 0</code>
will force the EIM to be computed using the SFS algorithm only
(this <em>used to be</em> the default method for <em>all</em> the observations).
When the fitted values of the model are large and <i>k</i> is small,
the computation of the EIM will be costly with respect to time
and memory if the exact method is used. Hence the argument
<code>max.support</code> limits the cost in terms of time.
For intercept-only models <code>max.support</code> is multiplied by
a number (such as 10) because only one inner product needs be computed.
Note: <code>max.support</code> is an upper bound and limits the number of
terms dictated by the <code>eps.trig</code> argument.
</p>


</td></tr>
<tr valign="top"><td><code>mds.min</code></td>
<td>

<p>Numeric.
Minimum value of the NBD mean divided by <code>size</code> parameter.
The closer this ratio is to 0, the closer the distribution is
to a Poisson.
Iterations will stop when an estimate of <i>k</i> is so large,
relative to the mean, than it is below this threshold
(this is treated as a boundary of the parameter space).
</p>
</td></tr>
<tr valign="top"><td><code>eps.trig</code></td>
<td>

<p>Numeric.
A small positive value used in the computation of the EIMs.
It focusses on the denominator of the terms of a series.
Each term in the series (that is used to approximate an infinite series)
has a value greater than <code>size / sqrt(eps.trig)</code>,
thus very small terms are ignored.
It's a good idea to set a smaller value that will result in more accuracy,
but it will require a greater computing time (when <i>k</i> is close to 0).
And adjustment to <code>max.support</code> may be needed.
In particular, the quantity computed by special means
is <i>trigamma(k) - E[trigamma(Y+k)]</i>,
which is the difference between two
<code><a href="../../base/html/trigamma.html">trigamma</a></code>.
functions. It is part of the calculation of the EIM with
respect to the <code>size</code> parameter.
</p>
</td></tr>
<tr valign="top"><td><code>gsize.mux</code></td>
<td>

<p>Similar to <code>gsigma</code> in <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code>.
However, this grid is multiplied by the initial
estimates of the NBD mean parameter.
That is, it is on a relative scale rather than on an
absolute scale.
If the counts are very large in value then convergence fail might
occur; if so, then try a smaller value such as
<code>gsize.mux = exp(-40)</code>.
</p>
</td></tr>
</table>







<table summary="R argblock">
<tr valign="top"><td><code>type.fitted, percentiles</code></td>
<td>

<p>See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information.
</p>
</td></tr>
<tr valign="top"><td><code>deviance.arg</code></td>
<td>

<p>Logical.
If <code>TRUE</code>, the deviance is computed <em>after</em> convergence.
It only works in the NB-2 model.
It is also necessary to set <code>criterion = "coefficients"</code>
or <code>half.step = FALSE</code>
since
one cannot use that criterion properly for the minimization
within the IRLS algorithm.
It should be set <code>TRUE</code> when
used with <code><a href="cqo.html">cqo</a></code> under the fast algorithm.
</p>








</td></tr>
<tr valign="top"><td><code>imethod</code></td>
<td>

<p>An integer with value <code>1</code> or <code>2</code> etc. which
specifies the initialization method for the <i>mu</i> parameter.
If failure to converge occurs try another value
and/or else specify a value for <code>iprobs.y</code>
and/or else specify a value for <code>isize</code>.
</p>
</td></tr>
<tr valign="top"><td><code>parallel</code></td>
<td>

<p>See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information.
Setting <code>parallel = TRUE</code> is useful in order to get
something similar to <code><a href="../../stats/html/quasipoisson.html">quasipoisson</a></code> or
what is known as NB-1.
If <code>parallel = TRUE</code> then the parallelism constraint
does not apply to any intercept term.
You should set <code>zero = NULL</code> too if <code>parallel = TRUE</code> to
avoid a conflict.
</p>
</td></tr>
<tr valign="top"><td><code>gprobs.y</code></td>
<td>

<p>A vector representing a grid;
passed into the <code>probs</code> argument
of <code><a href="../../stats/html/quantile.html">quantile</a></code>
when <code>imethod = 1</code> to obtain an initial value for the mean
of each response. Is overwritten by any value of <code>iprobs.y</code>.
</p>
</td></tr>
<tr valign="top"><td><code>iprobs.y</code></td>
<td>

<p>Passed into the <code>probs</code> argument
of <code><a href="../../stats/html/quantile.html">quantile</a></code>
when <code>imethod = 1</code> to obtain an initial value for the mean
of each response. Overwrites any value of <code>gprobs.y</code>.
This argument might be deleted in the future.
</p>
</td></tr>
</table>








<table summary="R argblock">
<tr valign="top"><td><code>zero</code></td>
<td>

<p>Can be an integer-valued vector, and if so, then
it is usually assigned <i>-2</i>
or <i>2</i>. Specifies which of the two
linear/additive predictors are modelled as an intercept
only. By default, the <i>k</i> parameter (after <code>lsize</code>
is applied) is modelled as a single unknown number that
is estimated. It can be modelled as a function of the
explanatory variables by setting <code>zero = NULL</code>; this
has been called a NB-H model by Hilbe (2011). A negative
value means that the value is recycled, so setting <i>-2</i>
means all <i>k</i> are intercept-only.
See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information.
Because of the new labelling for <code><a href="nbcanlink.html">nbcanlink</a></code> the default
is now <code>-2</code> rather than <code>"size"</code>; the latter is more
understandable really.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The negative binomial distribution (NBD)
can be motivated in several ways,
e.g., as a Poisson distribution with a mean that is gamma
distributed.
There are several common parametrizations of the NBD.
The one used by <code>negbinomial()</code> uses the
mean <i>mu</i> and an <em>index</em> parameter
<i>k</i>, both which are positive.
Specifically, the density of a random variable <i>Y</i> is
</p>
<p style="text-align: center;"><i>
    f(y;mu,k) = C_{y}^{y + k - 1}
    [mu/(mu+k)]^y [k/(k+mu)]^k</i></p>

<p>where <i>y=0,1,2,&hellip;</i>,
and <i>mu &gt; 0</i> and <i>k &gt; 0</i>.
Note that the <em>dispersion</em> parameter is
<i>1/k</i>, so that as <i>k</i> approaches infinity the
NBD approaches a Poisson distribution.
The response has variance <i>Var(Y)=mu*(1+mu/k)</i>.
When fitted, the <code>fitted.values</code> slot of the object contains
the estimated value of the <i>mu</i> parameter, i.e., of the mean
<i>E(Y)</i>.
It is common for some to use <i>alpha=1/k</i> as the
ancillary or heterogeneity parameter;
so common alternatives for <code>lsize</code> are
<code><a href="loge.html">negloge</a></code> and
<code><a href="reciprocal.html">reciprocal</a></code>.
</p>
<p>For <code>polya</code> the density is
</p>
<p style="text-align: center;"><i>
    f(y;p,k) = C_{y}^{y + k - 1}
    [1 - p]^y p^k</i></p>

<p>where <i>y=0,1,2,&hellip;</i>,
and <i>k &gt; 0</i> and <i>0 &lt; p &lt; 1</i>.
</p>
<p>Family function <code>polyaR()</code> is the same as <code>polya()</code> except
the order of the two parameters are switched.
The reason is that <code>polyaR()</code> tries to match with
<code><a href="../../stats/html/NegBinomial.html">rnbinom</a></code> closely
in terms of the argument order, etc.
Should the probability parameter be of primary interest,
probably, users will prefer using  <code>polya()</code> rather than
<code>polyaR()</code>.
Possibly <code>polyaR()</code> will be decommissioned one day.
</p>
<p>The NBD can be coerced into the
classical GLM framework with one of the parameters being
of interest and the other treated as a nuisance/scale
parameter (this is implemented in the <span class="pkg">MASS</span> library). The
<span class="pkg">VGAM</span> family function <code>negbinomial()</code> treats both
parameters on the same footing, and estimates them both
by full maximum likelihood estimation.
</p>


<p>The parameters <i>mu</i> and <i>k</i> are independent
(diagonal EIM), and the confidence region for <i>k</i>
is extremely skewed so that its standard error is often
of no practical use. The parameter <i>1/k</i> has been
used as a measure of aggregation.
For the NB-C the EIM is not diagonal.
</p>
<p>These <span class="pkg">VGAM</span> family functions handle
<em>multiple</em> responses, so that a response matrix can be
inputted. The number of columns is the number
of species, say, and setting <code>zero = -2</code> means that
<em>all</em> species have a <i>k</i> equalling a (different)
intercept only.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> (see <code><a href="vglmff-class.html">vglmff-class</a></code>).
The object is used by modelling functions such as <code><a href="vglm.html">vglm</a></code>,
<code><a href="rrvglm.html">rrvglm</a></code>
and <code><a href="vgam.html">vgam</a></code>.
</p>


<h3>Warning</h3>

<p>Poisson regression corresponds to <i>k</i> equalling
infinity.  If the data is Poisson or close to Poisson,
numerical problems may occur.
Some corrective measures are taken, e.g.,
<i>k</i> is effectively capped (relative to the mean) during estimation
to some large value and a warning is issued.
And setting <code>stepsize = 0.5</code> for half stepping is
probably a good idea too when the data is extreme.
</p>














<p>The NBD is a strictly unimodal
distribution. Any data set that does not exhibit a mode (somewhere
in the middle) makes the estimation problem difficult.
Set <code>trace = TRUE</code> to monitor convergence.
</p>
<p>These functions are fragile; the maximum likelihood
estimate of the index parameter is fraught (see Lawless, 1987).
Other alternatives to <code>negbinomial</code> are
to fit a NB-1 or RR-NB (aka NB-P) model; see Yee (2014).
Also available are the NB-C, NB-H and NB-G.
Assigning values to the <code>isize</code> argument may lead
to a local solution, and smaller values are preferred
over large values when using this argument.
</p>

<p>If one wants to force SFS
to be used on all observations, then
set <code>max.support = 0</code> or <code>max.chunk.MB = 0</code>.
If one wants to force the exact method
to be used for all observations, then
set <code>max.support = Inf</code>.
If the computer has <em>much</em> memory, then trying
<code>max.chunk.MB = Inf</code> and
<code>max.support = Inf</code>
may provide a small speed increase.
If SFS is used at all, then the <code>@weights</code> slot of the
fitted object will be a matrix;
otherwise that slot will be a <code>0 x 0</code> matrix.
</p>
<p>Yet to do: write a family function which uses the methods
of moments estimator for <i>k</i>.
</p>


<h3>Note</h3>




<p>These 3 functions implement 2 common parameterizations
of the negative binomial (NB). Some people called the
NB with integer <i>k</i> the <em>Pascal</em> distribution,
whereas if <i>k</i> is real then this is the <em>Polya</em>
distribution. I don't. The one matching the details of
<code><a href="../../stats/html/NegBinomial.html">rnbinom</a></code> in terms of <i>p</i>
and <i>k</i> is <code>polya()</code>.
</p>
<p>For <code>polya()</code> the code may fail when <i>p</i> is close
to 0 or 1. It is not yet compatible with <code><a href="cqo.html">cqo</a></code>
or <code><a href="cao.html">cao</a></code>.
</p>
<p>Suppose the response is called <code>ymat</code>.
For <code>negbinomial()</code>
the diagonal element of the <em>expected information matrix</em>
(EIM) for parameter <i>k</i>
involves an infinite series; consequently SFS
(see <code>nsimEIM</code>) is used as the backup algorithm only.
SFS should be better if <code>max(ymat)</code> is large,
e.g., <code>max(ymat) &gt; 1000</code>,
or if there are any outliers in <code>ymat</code>.
The default algorithm involves a finite series approximation
to the support <code>0:Inf</code>;
the arguments
<code>max.memory</code>,
<code>min.size</code> and
<code>cutoff.prob</code> are pertinent.
</p>



<p>Regardless of the algorithm used,
convergence problems may occur, especially when the response has large
outliers or is large in magnitude.
If convergence failure occurs, try using arguments
(in recommended decreasing order)
<code>max.support</code>,
<code>nsimEIM</code>,
<code>cutoff.prob</code>,
<code>iprobs.y</code>,
<code>imethod</code>,
<code>isize</code>,
<code>zero</code>,
<code>max.chunk.MB</code>.
</p>
<p>The function <code>negbinomial</code> can be used by the fast algorithm in
<code><a href="cqo.html">cqo</a></code>, however, setting <code>eq.tolerances = TRUE</code> and
<code>I.tolerances = FALSE</code> is recommended.
</p>







<p>In the first example below (Bliss and Fisher, 1953), from each of 6
McIntosh apple trees in an orchard that had been sprayed, 25 leaves
were randomly selected. On each of the leaves, the number of adult
female European red mites were counted.
</p>
<p>There are two special uses of <code>negbinomial</code> for handling count data.
Firstly,
when used by <code><a href="rrvglm.html">rrvglm</a></code>  this
results in a continuum of models in between and
inclusive of quasi-Poisson and negative binomial regression.
This is known as a reduced-rank negative binomial model <em>(RR-NB)</em>.
It fits a negative binomial log-linear regression with variance function
<i>Var(Y) = mu + delta1 * mu^delta2</i>
where <i>delta1</i>
and   <i>delta2</i>
are parameters to be estimated by MLE.
Confidence intervals are available for <i>delta2</i>,
therefore it can be decided upon whether the
data are quasi-Poisson or negative binomial, if any.
</p>
<p>Secondly,
the use of <code>negbinomial</code> with <code>parallel = TRUE</code>
inside <code><a href="vglm.html">vglm</a></code>
can result in a model similar to <code><a href="../../stats/html/quasipoisson.html">quasipoisson</a></code>.
This is named the <em>NB-1</em> model.
The dispersion parameter is estimated by MLE whereas
<code><a href="../../stats/html/glm.html">glm</a></code> uses the method of moments.
In particular, it fits a negative binomial log-linear regression
with variance function
<i>Var(Y) = phi0 * mu</i>
where <i>phi0</i>
is a parameter to be estimated by MLE.
Confidence intervals are available for <i>phi0</i>.
</p>


<h3>Author(s)</h3>

<p> Thomas W. Yee,
and with a lot of help by Victor Miranda
to get it going with <code><a href="nbcanlink.html">nbcanlink</a></code> (NB-C).
</p>


<h3>References</h3>

<p>Lawless, J. F. (1987)
Negative binomial and mixed Poisson regression.
<em>The Canadian Journal of Statistics</em>
<b>15</b>, 209&ndash;225.
</p>
<p>Hilbe, J. M. (2011)
<em>Negative Binomial Regression</em>,
2nd Edition.
Cambridge: Cambridge University Press.
</p>
<p>Bliss, C. and Fisher, R. A. (1953)
Fitting the negative binomial distribution to biological data.
<em>Biometrics</em>
<b>9</b>, 174&ndash;200.
</p>
<p>Yee, T. W. (2014)
Reduced-rank vector generalized linear models with two linear predictors.
<em>Computational Statistics and Data Analysis</em>,
<b>71</b>, 889&ndash;902.
</p>


<h3>See Also</h3>

<p><code><a href="../../stats/html/quasipoisson.html">quasipoisson</a></code>,
<code><a href="poissonff.html">poissonff</a></code>,
<code><a href="zinegbinomial.html">zinegbinomial</a></code>,
<code><a href="negbinomial.size.html">negbinomial.size</a></code> (e.g., NB-G),
<code><a href="nbcanlink.html">nbcanlink</a></code> (NB-C),
<code><a href="posnegbinomial.html">posnegbinomial</a></code>,
<code><a href="inv.binomial.html">inv.binomial</a></code>,
<code><a href="../../stats/html/NegBinomial.html">rnbinom</a></code>,
<code><a href="nbolf.html">nbolf</a></code>,
<code><a href="rrvglm.html">rrvglm</a></code>,
<code><a href="cao.html">cao</a></code>,
<code><a href="cqo.html">cqo</a></code>,
<code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code>,
<code><a href="simulate.vlm.html">simulate.vlm</a></code>,
<code><a href="../../stats/html/ppoints.html">ppoints</a></code>,
<code><a href="../../stats/html/NegBinomial.html">qnbinom</a></code>.
</p>




<h3>Examples</h3>

<pre>
# Example 1: apple tree data (Bliss and Fisher, 1953)
appletree &lt;- data.frame(y = 0:7, w = c(70, 38, 17, 10, 9, 3, 2, 1))
fit &lt;- vglm(y ~ 1, negbinomial(deviance = TRUE), data = appletree,
            weights = w, crit = "coef")  # Obtain the deviance
fit &lt;- vglm(y ~ 1, negbinomial(deviance = TRUE), data = appletree,
            weights = w, half.step = FALSE)  # Alternative method
summary(fit)
coef(fit, matrix = TRUE)
Coef(fit)  # For intercept-only models
deviance(fit)  # NB2 only; needs 'crit = "coef"' &amp; 'deviance = TRUE' above

# Example 2: simulated data with multiple responses
## Not run: 
ndata &lt;- data.frame(x2 = runif(nn &lt;- 200))
ndata &lt;- transform(ndata, y1 = rnbinom(nn, mu = exp(3+x2), size = exp(1)),
                          y2 = rnbinom(nn, mu = exp(2-x2), size = exp(0)))
fit1 &lt;- vglm(cbind(y1, y2) ~ x2, negbinomial, data = ndata, trace = TRUE)
coef(fit1, matrix = TRUE)

## End(Not run)

# Example 3: large counts implies SFS is used
## Not run: 
ndata &lt;- transform(ndata, y3 = rnbinom(nn, mu = exp(10+x2), size = exp(1)))
with(ndata, range(y3))  # Large counts
fit2 &lt;- vglm(y3 ~ x2, negbinomial, data = ndata, trace = TRUE)
coef(fit2, matrix = TRUE)
head(fit2@weights)  # Non-empty; SFS was used

## End(Not run)

# Example 4: a NB-1 to estimate a negative binomial with Var(Y) = phi0 * mu
nn &lt;- 200  # Number of observations
phi0 &lt;- 10  # Specify this; should be greater than unity
delta0 &lt;- 1 / (phi0 - 1)
mydata &lt;- data.frame(x2 = runif(nn), x3 = runif(nn))
mydata &lt;- transform(mydata, mu = exp(2 + 3 * x2 + 0 * x3))
mydata &lt;- transform(mydata, y3 = rnbinom(nn, mu = mu, size = delta0 * mu))
## Not run: 
plot(y3 ~ x2, data = mydata, pch = "+", col = "blue",
     main = paste("Var(Y) = ", phi0, " * mu", sep = ""), las = 1) 
## End(Not run)
nb1 &lt;- vglm(y3 ~ x2 + x3, negbinomial(parallel = TRUE, zero = NULL),
            data = mydata, trace = TRUE)
# Extracting out some quantities:
cnb1 &lt;- coef(nb1, matrix = TRUE)
mydiff &lt;- (cnb1["(Intercept)", "loge(size)"] -
           cnb1["(Intercept)", "loge(mu)"])
delta0.hat &lt;- exp(mydiff)
(phi.hat &lt;- 1 + 1 / delta0.hat)  # MLE of phi
summary(nb1)
# Obtain a 95 percent confidence interval for phi0:
myvec &lt;- rbind(-1, 1, 0, 0)
(se.mydiff &lt;- sqrt(t(myvec) %*%  vcov(nb1) %*%  myvec))
ci.mydiff &lt;- mydiff + c(-1.96, 1.96) * se.mydiff
ci.delta0 &lt;- ci.exp.mydiff &lt;- exp(ci.mydiff)
(ci.phi0 &lt;- 1 + 1 / rev(ci.delta0))  # The 95 percent conf. interval for phi0

Confint.nb1(nb1)  # Quick way to get it

summary(glm(y3 ~ x2 + x3, quasipoisson, mydata))$disper  # cf. moment estimator
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-6 <a href="00Index.html">Index</a>]</div>
</body></html>
