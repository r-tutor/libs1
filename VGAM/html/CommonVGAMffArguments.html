<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Common VGAM Family Function Arguments</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for CommonVGAMffArguments {VGAM}"><tr><td>CommonVGAMffArguments {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Common VGAM Family Function Arguments </h2>

<h3>Description</h3>

<p>Here is a description of some common and typical arguments found
in many <span class="pkg">VGAM</span> family functions, e.g.,
<code>lsigma</code>,
<code>isigma</code>,
<code>gsigma</code>,
<code>nsimEI</code>,
<code>parallel</code> and
<code>zero</code>.
</p>


<h3>Usage</h3>

<pre>
TypicalVGAMfamilyFunction(lsigma = "loge",
                          isigma = NULL,
                          link.list = list("(Default)" = "identitylink",
                                           x2          = "loge",
                                           x3          = "logoff",
                                           x4          = "multilogit",
                                           x5          = "multilogit"),
                          earg.list = list("(Default)" = list(),
                                           x2          = list(),
                                           x3          = list(offset = -1),
                                           x4          = list(),
                                           x5          = list()),
                          gsigma = exp(-5:5),
                          parallel = TRUE,
                          ishrinkage = 0.95,
                          nointercept = NULL, imethod = 1,
                          type.fitted = c("mean", "quantiles",
                                          "pobs0", "pstr0", "onempstr0"),
                          percentiles = c(25, 50, 75),
                          probs.x = c(0.15, 0.85),
                          probs.y = c(0.25, 0.50, 0.75),
                          multiple.responses = FALSE, earg.link = FALSE,
                          whitespace = FALSE, bred = FALSE, lss = TRUE,
                          oim = FALSE, nsimEIM = 100, byrow.arg = FALSE,
                          zero = NULL)
</pre>


<h3>Arguments</h3>


<table summary="R argblock">
<tr valign="top"><td><code>lsigma</code></td>
<td>

<p>Character.
Link function applied to a parameter and not necessarily a mean.
See <code><a href="Links.html">Links</a></code> for a selection of choices.
If there is only one parameter then this argument is often called
<code>link</code>.
</p>
</td></tr>
</table>








<table summary="R argblock">
<tr valign="top"><td><code>link.list, earg.list</code></td>
<td>

<p>Some <span class="pkg">VGAM</span> family functions
(such as <code><a href="normal.vcm.html">normal.vcm</a></code>)
implement models with
potentially lots of parameter link functions.
These two arguments allow many such links and extra arguments
to be inputted more easily.
One has something like
<code>link.list = list("(Default)" = "identitylink", x2 = "loge", x3 = "logoff")</code>
and
<code>earg.list = list("(Default)" = list(), x2 = list(), x3 = "list(offset = -1)")</code>.
Then any unnamed terms will have the default link with its
corresponding extra argument.
Note: the <code><a href="multilogit.html">multilogit</a></code> link is also possible, and if so,
at least two instances of it are necessary.
Then the last term is the baseline/reference group.
</p>
</td></tr>
<tr valign="top"><td><code>isigma</code></td>
<td>

<p>Optional initial values can often be inputted using an argument
beginning with <code>"i"</code>.
For example, <code>"isigma"</code> and <code>"ilocation"</code>, or just
<code>"init"</code> if there is one parameter.
A value of <code>NULL</code> means a value is computed internally, i.e.,
a <em>self-starting</em> <span class="pkg">VGAM</span> family function.
If a failure to converge occurs make use of these types of arguments.
</p>
</td></tr>
<tr valign="top"><td><code>gsigma</code></td>
<td>

<p>Grid-search initial values can be inputted using an argument
beginning with <code>"g"</code>,
e.g., <code>"gsigma"</code>, <code>"gshape"</code> and <code>"gscale"</code>.
If argument <code>isigma</code> is inputted then that has precedence over
<code>gsigma</code>, etc.

If the grid search is 2-dimensional then it is advisable not to
make the vectors too long as a nested <code>for</code> loop may be used.
Ditto for 3-dimensions etc.
Sometimes a <code>".mux"</code> is added as a suffix, e.g., <code>gshape.mux</code>;
this means that the grid is created relatively and not absolutely,
e.g., its values are multipled by some single initial estimate of the
parameter in order to create the grid on an absolute scale.
</p>
<p>Some family functions have an argument called <code>gprobs.y</code>.
This is fed into the <code>probs</code>
argument of <code><a href="../../stats/html/quantile.html">quantile</a></code> in order to
obtain some values of central tendency of the response,
i.e., some spread of values in the middle.
when <code>imethod = 1</code> to obtain an initial value for the mean
Some family functions have an argument called <code>iprobs.y</code>, and
if so, then these values can overwrite <code>gprobs.y</code>.
</p>


</td></tr>
<tr valign="top"><td><code>parallel</code></td>
<td>

<p>A logical, or a simple formula specifying which terms have equal/unequal
coefficients.
The formula must be simple, i.e., additive with simple main effects terms.
Interactions and nesting etc. are not handled.
To handle complex formulas use the <code>constraints</code> argument
(of <code><a href="vglm.html">vglm</a></code> etc.);
however, there is a lot more setting up involved and things will
not be as convenient.
</p>
<p>Here are some examples.
1. <code>parallel = TRUE ~ x2 + x5</code> means the parallelism assumption
is only applied to <i>X_2</i>, <i>X_5</i> and the intercept.
2.  <code>parallel = TRUE ~ -1</code>
and <code>parallel = TRUE ~ 0</code>
mean the parallelism assumption
is applied to <em>no</em> variables at all.
Similarly,
<code>parallel = FALSE ~ -1</code> and
<code>parallel = FALSE ~ 0</code>
mean the parallelism assumption
is applied to <em>all</em> the variables including the intercept.
3.  <code>parallel = FALSE ~ x2 - 1</code>
and <code>parallel = FALSE ~ x2 + 0</code>
applies the
parallelism constraint to all terms (including the intercept)
except for <i>X_2</i>.
</p>
<p>This argument is common in <span class="pkg">VGAM</span> family functions for categorical
responses, e.g., <code><a href="cumulative.html">cumulative</a></code>,  <code><a href="acat.html">acat</a></code>,
<code><a href="cratio.html">cratio</a></code>, <code><a href="sratio.html">sratio</a></code>.
For the proportional odds model (<code><a href="cumulative.html">cumulative</a></code>) having
parallel constraints applied to each explanatory variable (except for
the intercepts) means the fitted probabilities do not become negative
or greater than 1. However this parallelism or proportional-odds
assumption ought to be checked.
</p>
</td></tr>
</table>









<table summary="R argblock">
<tr valign="top"><td><code>nsimEIM</code></td>
<td>

<p>Some <span class="pkg">VGAM</span> family functions use simulation to obtain an approximate
expected information matrix (EIM).
For those that do, the <code>nsimEIM</code> argument specifies the number
of random variates used per observation; the mean of <code>nsimEIM</code>
random variates is taken.
Thus <code>nsimEIM</code> controls the accuracy and a larger value may be
necessary if the EIMs are not positive-definite.
For intercept-only models (<code>y ~ 1)</code> the value of <code>nsimEIM</code>
can be smaller (since the common value used is also then taken as the
mean over the observations), especially if the number of observations
is large.
</p>
<p>Some <span class="pkg">VGAM</span> family functions provide two algorithms for estimating
the EIM.
If applicable, set <code>nsimEIM = NULL</code> to choose the other algorithm.
</p>
</td></tr>
<tr valign="top"><td><code>imethod</code></td>
<td>

<p>An integer with value <code>1</code> or <code>2</code> or <code>3</code> or ... which
specifies the initialization method for some parameters or a specific
parameter.
If failure to converge occurs try the next higher value, and
continue until success.
For example, <code>imethod = 1</code> might be the method of moments,
and <code>imethod = 2</code> might be another method.
If no value of <code>imethod</code> works then it will be necessary
to use arguments such as <code>isigma</code>.
For many <span class="pkg">VGAM</span> family functions it is advisable to try
this argument with all possible values to safeguard against
problems such as converging to a local solution.
<span class="pkg">VGAM</span> family functions with this argument usually correspond
to a model or distribution that is relatively hard to fit successfully,
therefore care is needed to ensure the global solution is obtained.
So using all possible values that this argument supplies is a good idea.
</p>
</td></tr>
<tr valign="top"><td><code>type.fitted</code></td>
<td>

<p>Character.
Type of fitted value returned by the <code>fitted()</code> methods function.
The first choice is always the default.
The available choices depends on what kind of family function it is.
Using the first few letters of the chosen choice is okay.
See <code><a href="fittedvlm.html">fittedvlm</a></code> for more details.
</p>
</td></tr>
<tr valign="top"><td><code>percentiles</code></td>
<td>

<p>Numeric vector, with values between 0 and 100
(although it is not recommended that exactly 0 or 100 be inputted).
Used only if <code>type.fitted = "quantiles"</code> or
<code>type.fitted = "percentiles"</code>, then
this argument specifies the values of these quantiles.
The argument name tries to reinforce that the values
lie between 0 and 100.
See <code><a href="fittedvlm.html">fittedvlm</a></code> for more details.
</p>
</td></tr>
<tr valign="top"><td><code>probs.x, probs.y</code></td>
<td>

<p>Numeric, with values in (0, 1).
The probabilites that define quantiles with respect to some vector,
usually an <code>x</code> or <code>y</code> of some sort.
This is used to create two subsets of data corresponding to &lsquo;low&rsquo; and
&lsquo;high&rsquo; values of x or y.
Each value is separately fed into the <code>probs</code> argument
of <code><a href="../../stats/html/quantile.html">quantile</a></code>.
If the data set size is small then it may be necessary to
increase/decrease slightly the first/second values respectively.
</p>
</td></tr>
<tr valign="top"><td><code>lss</code></td>
<td>

<p>Logical.
This stands for the ordering: location, scale and shape.
Should the ordering of the parameters be in this order?
Almost all <span class="pkg">VGAM</span> family functions have this order by default,
but in order to match the arguments of existing R functions, one
might need to set <code>lss = FALSE</code>.
For example, the arguments of <code><a href="weibullR.html">weibullR</a></code> are
scale and shape, whereas <code><a href="../../stats/html/rweibull.html">rweibull</a></code>
are shape and scale.
As a temporary measure
(from <span class="pkg">VGAM</span> 0.9-7 onwards but prior to version 1.0-0),
some family functions such as <code><a href="sinmad.html">sinmad</a></code> have an
<code>lss</code> argument without a default. For these,
setting <code>lss = FALSE</code> will work.
Later, <code>lss = TRUE</code> will be the default.
Be careful for the <code>dpqr</code>-type functions, e.g.,
<code><a href="sinmadUC.html">rsinmad</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>whitespace</code></td>
<td>

<p>Logical.
Should white spaces (<code>" "</code>) be used in the
labelling of the linear/additive predictors?
Setting <code>TRUE</code> usually results in more readability but
it occupies more columns of the output.
</p>
</td></tr>
<tr valign="top"><td><code>oim</code></td>
<td>

<p>Logical.
Should the observed information matrices (OIMs) be used for
the working weights?
In general, setting <code>oim = TRUE</code> means the Newton-Raphson
algorithm, and <code>oim = FALSE</code> means Fisher-scoring.
The latter uses the EIM, and is usually recommended.
If <code>oim = TRUE</code> then <code>nsimEIM</code> is ignored.
</p>
</td></tr>
<tr valign="top"><td><code>zero</code></td>
<td>

<p>Either an integer vector, or a vector of character strings.
</p>
<p>If an integer, then it specifies which
linear/additive predictor is modelled as <em>intercept-only</em>.
That is, the regression coefficients are
set to zero for all covariates except for the intercept.
If <code>zero</code> is specified then it may be a vector with values
from the set <i>\{1,2,&hellip;,M\}</i>.
The value <code>zero = NULL</code> means model <em>all</em> linear/additive
predictors as functions of the explanatory variables.
Here, <i>M</i> is the number of linear/additive predictors.
Technically, if <code>zero</code> contains the value <i>j</i> then
the <i>j</i>th row of every constraint matrix (except for the
intercept) consists of all 0 values.
</p>
<p>Some <span class="pkg">VGAM</span> family functions allow the <code>zero</code> argument to
accept negative values; if so then its absolute value is recycled
over each (usual) response. For example, <code>zero = -2</code> for the
two-parameter negative binomial distribution would mean,
for each response, the second linear/additive predictor is modelled
as intercepts-only. That is, for all the <i>k</i> parameters in
<code><a href="negbinomial.html">negbinomial</a></code> (this <span class="pkg">VGAM</span> family function can handle
a matrix of responses).
</p>
<p>Suppose <code>zero = zerovec</code> where <code>zerovec</code> is a vector
of negative values. If <i>G</i> is the usual <i>M</i> value for
a univariate response then the actual values for argument <code>zero</code>
are all values in
<code>c(abs(zerovec), G + abs(zerovec), 2*G + abs(zerovec), ... )</code>
lying in the integer range <i>1</i> to <i>M</i>.
For example, setting <code>zero = -c(2, 3)</code> for a matrix response
of 4 columns with <code><a href="zinegbinomial.html">zinegbinomial</a></code> (which
usually has <i>G = M = 3</i> for a univariate response)
would be equivalent to <code>zero = c(2, 3, 5, 6, 8, 9, 11, 12)</code>.
This example has <i>M = 12</i>.
Note that if <code>zerovec</code> contains negative values then their
absolute values should be elements from the set <code>1:G</code>.
</p>
<p>Note: <code>zero</code> may have positive and negative values,
for example, setting <code>zero = c(-2, 3)</code> in the above example
would be equivalent to <code>zero = c(2, 3, 5, 8, 11)</code>.
</p>
<p>The argument <code>zero</code> also
accepts a character vector (for <span class="pkg">VGAM</span> 1.0-1 onwards).
Each value is fed into <code><a href="../../base/html/grep.html">grep</a></code> with
<code>fixed = TRUE</code>, meaning that wildcards <code>"*"</code> are not useful.
See the example below&mdash;all the variants work;
those with <code>LOCAT</code> issue a warning that that value is unmatched.
Importantly, the parameter names
are <code>c("location1", "scale1", "location2", "scale2")</code>
because there are 2 responses.
Yee (2015) described <code>zero</code> for only numerical input.
Allowing character input is particularly important when the
number of parameters cannot be determined without having the actual
data first. For example, with time series data, an ARMA(<i>p</i>,<i>q</i>) process
might have parameters <i>&theta;_1,&hellip;,&theta;_p</i> which should
be intercept-only by default. Then specifying a numerical default
value for <code>zero</code> would be too difficult (there are the drift
and scale parameters too).
However, it is possible with the character representation:
<code>zero = "theta"</code> would achieve this.
In the future, most <span class="pkg">VGAM</span> family functions might be converted
to the character representation&mdash;the advantage being that it
is more readable.
When programming a <span class="pkg">VGAM</span> family function that allows character
input, the variable <code>predictors.names</code>
must be assigned correctly.
</p>






</td></tr>
<tr valign="top"><td><code>ishrinkage</code></td>
<td>

<p>Shrinkage factor <i>s</i> used for obtaining initial values.
Numeric, between 0 and 1.
In general, the formula used is something like
<i>s*mu + (1-s)*y</i>
where <i>mu</i> is a measure of central tendency such as a weighted
mean or median, and <i>y</i> is the response vector.
For example, the initial values are slight perturbations of
the mean towards the actual data.
For many types of models this method seems to work well and is often
reasonably robust to outliers in the response.
Often this argument is only used if
the argument <code>imethod</code> is assigned a certain value.
</p>
</td></tr>
<tr valign="top"><td><code>nointercept</code></td>
<td>

<p>An integer-valued vector specifying which
linear/additive predictors have no intercepts.
Any values must be from the set {1,2,...,<i>M</i>}.
A value of <code>NULL</code> means no such constraints.
</p>
</td></tr>
<tr valign="top"><td><code>multiple.responses</code></td>
<td>

<p>Logical.
Some <span class="pkg">VGAM</span> family functions allow a multivariate or vector response.
If so, then usually the response is a matrix with columns
corresponding to the individual response variables.
They are all fitted simultaneously.
Arguments such as <code>parallel</code> may then be useful to allow
for relationships between the regressions of each response variable.
If <code>multiple.responses = TRUE</code> then sometimes the response is interpreted
differently, e.g., <code><a href="posbinomial.html">posbinomial</a></code> chooses the first
column of a matrix response as success and combines the other
columns as failure, but when <code>multiple.responses = TRUE</code> then each column
of the response matrix is the number of successes and the
<code>weights</code> argument is of the same dimension as the
response and contains the number of trials.
</p>
</td></tr>
<tr valign="top"><td><code>earg.link</code></td>
<td>

<p>This argument should be generally ignored.
</p>


</td></tr>
<tr valign="top"><td><code>byrow.arg</code></td>
<td>

<p>Logical.
Some <span class="pkg">VGAM</span> family functions that handle multiple responses
have arguments that allow input to be fed in which affect
all the responses,
e.g., <code>imu</code> for initalizing a <code>mu</code> parameter.
In such cases it is sometime more convenient
to input one value per response by
setting <code>byrow.arg = TRUE</code>; then values are recycled
in order to form a matrix of the appropriate dimension.
This argument matches <code>byrow</code> in <code><a href="../../base/html/matrix.html">matrix</a></code>;
in fact it is fed into such using <code>matrix(..., byrow = byrow.arg)</code>.
This argument has no effect when there is one response.
</p>
</td></tr>
<tr valign="top"><td><code>bred</code></td>
<td>

<p>Logical.
Some <span class="pkg">VGAM</span> family functions will allow bias-reduction based
on the work by Kosmidis and Firth.
Sometimes half-stepping is a good idea; set <code>stepsize = 0.5</code>
and monitor convergence by setting <code>trace = TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Full details will be given in documentation yet to be written,
at a later date!
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> (see <code><a href="vglmff-class.html">vglmff-class</a></code>).
The object is used by modelling functions such as <code><a href="vglm.html">vglm</a></code>
and <code><a href="vgam.html">vgam</a></code>.
</p>


<h3>Warning </h3>

<p>The <code>zero</code> argument is supplied for convenience but conflicts
can arise with other arguments, e.g., the <code>constraints</code>
argument of <code><a href="vglm.html">vglm</a></code> and <code><a href="vgam.html">vgam</a></code>.
See Example 5 below for an example.
If not sure, use, e.g., <code>constraints(fit)</code> and
<code>coef(fit, matrix = TRUE)</code> to check the result of a fit <code>fit</code>.
</p>
<p>The arguments <code>zero</code> and <code>nointercept</code> can be inputted
with values that fail. For example,
<code>multinomial(zero = 2, nointercept = 1:3)</code> means the
second linear/additive predictor is identically zero,
which will cause a failure.
</p>
<p>Be careful about the use of other potentially contradictory constraints,
e.g., <code>multinomial(zero = 2, parallel = TRUE ~ x3)</code>. If in doubt,
apply <code>constraints()</code> to the fitted object to check.
</p>
<p><span class="pkg">VGAM</span> family functions with the <code>nsimEIM</code> may have inaccurate
working weight matrices. If so, then the standard errors of the
regression coefficients may be inaccurate. Thus output from
<code>summary(fit)</code>,
<code>vcov(fit)</code>,
etc. may be misleading.
</p>
<p>Changes relating to the codelss argument have very important
consequences and users must beware.
Good programming style is to rely on the argument names and not
on the order.
</p>


<h3>Note</h3>

<p>See <code><a href="Links.html">Links</a></code> regarding a major change in
link functions, for version 0.9-0 and higher
(released during the 2nd half of 2012).
</p>


<h3>Author(s)</h3>

<p>T. W. Yee</p>


<h3>References</h3>

<p>Yee, T. W. (2015)
Vector Generalized Linear and Additive Models:
With an Implementation in R.
New York, USA: <em>Springer</em>.
</p>
<p>Kosmidis, I. and Firth, D. (2009)
Bias reduction in exponential family nonlinear models.
<em>Biometrika</em>,
<b>96</b>(4), 793&ndash;804.
</p>






<h3>See Also</h3>

<p><code><a href="Links.html">Links</a></code>,
<code><a href="vglmff-class.html">vglmff-class</a></code>,
<code><a href="UtilitiesVGAM.html">UtilitiesVGAM</a></code>,
<code><a href="normal.vcm.html">normal.vcm</a></code>,
<code><a href="multilogit.html">multilogit</a></code>.
</p>


<h3>Examples</h3>

<pre>
# Example 1
cumulative()
cumulative(link = "probit", reverse = TRUE, parallel = TRUE)

# Example 2
wdata &lt;- data.frame(x2 = runif(nn &lt;- 1000))
wdata &lt;- transform(wdata,
         y = rweibull(nn, shape = 2 + exp(1 + x2), scale = exp(-0.5)))
fit &lt;- vglm(y ~ x2, weibullR(lshape = logoff(offset = -2), zero = 2), data = wdata)
coef(fit, mat = TRUE)

# Example 3; multivariate (multiple) response
## Not run: 
ndata &lt;- data.frame(x = runif(nn &lt;- 500))
ndata &lt;- transform(ndata,
           y1 = rnbinom(nn, mu = exp(3+x), size = exp(1)),  # k is size
           y2 = rnbinom(nn, mu = exp(2-x), size = exp(0)))
fit &lt;- vglm(cbind(y1, y2) ~ x, negbinomial(zero = -2), data = ndata)
coef(fit, matrix = TRUE)

## End(Not run)
# Example 4
## Not run: 
# fit1 and fit2 are equivalent
fit1 &lt;- vglm(ymatrix ~ x2 + x3 + x4 + x5,
             cumulative(parallel = FALSE ~ 1 + x3 + x5), data = cdata)
fit2 &lt;- vglm(ymatrix ~ x2 + x3 + x4 + x5,
             cumulative(parallel = TRUE ~ x2 + x4), data = cdata)

## End(Not run)

# Example 5
udata &lt;- data.frame(x2 = rnorm(nn &lt;- 200))
udata &lt;- transform(udata,
           y1 = rnorm(nn, mean = 1 - 3*x2, sd = exp(1 + 0.2*x2)),
           y2 = rnorm(nn, mean = 1 - 3*x2, sd = exp(1)))
args(uninormal)
fit1 &lt;- vglm(y1 ~ x2, uninormal, data = udata)            # This is okay
fit2 &lt;- vglm(y2 ~ x2, uninormal(zero = 2), data = udata)  # This is okay

# This creates potential conflict
clist &lt;- list("(Intercept)" = diag(2), "x2" = diag(2))
fit3 &lt;- vglm(y2 ~ x2, uninormal(zero = 2), data = udata,
             constraints = clist)  # Conflict!
coef(fit3, matrix = TRUE)  # Shows that clist[["x2"]] was overwritten,
constraints(fit3)  # i.e., 'zero' seems to override the 'constraints' arg

# Example 6 ('whitespace' argument)
pneumo &lt;- transform(pneumo, let = log(exposure.time))
fit1 &lt;- vglm(cbind(normal, mild, severe) ~ let,
             sratio(whitespace = FALSE, parallel = TRUE), data = pneumo)
fit2 &lt;- vglm(cbind(normal, mild, severe) ~ let,
             sratio(whitespace = TRUE,  parallel = TRUE), data = pneumo)
head(predict(fit1), 2)  # No white spaces
head(predict(fit2), 2)  # Uses white spaces

# Example 7 ('zero' argument with character input)
set.seed(123); n &lt;- 1000
ldata &lt;- data.frame(x2 = runif(n))
ldata &lt;- transform(ldata, y1 = rlogis(n, loc = 0+5*x2, scale = exp(2)))
ldata &lt;- transform(ldata, y2 = rlogis(n, loc = 0+5*x2, scale = exp(0+1*x2)))
ldata &lt;- transform(ldata, w1 = runif(n))
ldata &lt;- transform(ldata, w2 = runif(n))
fit7 &lt;- vglm(cbind(y1, y2) ~ x2,
#            logistic(zero = "location1"),  # location1 is intercept-only
#            logistic(zero = "location2"),
#            logistic(zero = "location*"),  # Not okay... all is unmatched
#            logistic(zero = "scale1"),
#            logistic(zero = "scale2"),
#            logistic(zero = "scale"),  # Both scale parameters are matched
             logistic(zero = c("location", "scale2")),  # All but scale1
#            logistic(zero = c("LOCAT", "scale2")),  # Only scale2 is matched
#            logistic(zero = c("LOCAT")),  # Nothing is matched
#            trace = TRUE,
#            weights = cbind(w1, w2),
             weights = w1,
             data = ldata)
coef(fit7, matrix = TRUE)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-6 <a href="00Index.html">Index</a>]</div>
</body></html>
