<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Binomial Family Function</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for binomialff {VGAM}"><tr><td>binomialff {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Binomial Family Function </h2>

<h3>Description</h3>

<p>Family function for fitting generalized linear models to binomial
responses
</p>





<h3>Usage</h3>

<pre>
binomialff(link = "logit", multiple.responses = FALSE,
       parallel = FALSE, zero = NULL, bred = FALSE, earg.link = FALSE)

</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>link</code></td>
<td>

<p>Link function;
see <code><a href="Links.html">Links</a></code> and
<code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information.
</p>
</td></tr>
</table>






<table summary="R argblock">
<tr valign="top"><td><code>multiple.responses</code></td>
<td>

<p>Multivariate response? If <code>TRUE</code>, then the response is
interpreted
as <i>M</i> independent binary responses, where <i>M</i> is the number
of columns of the response matrix. In this case, the response matrix
should have <i>Q</i> columns consisting of counts (successes),
and the <code>weights</code> argument should have <i>Q</i> columns
consisting of the number of trials (successes plus failures).
</p>

<p>If <code>FALSE</code> and the response is a (2-column) matrix, then the
number of successes is given in the first column, and the second
column is the number of failures.
</p>
</td></tr>
</table>







<table summary="R argblock">
<tr valign="top"><td><code>parallel</code></td>
<td>

<p>A logical or formula. Used only if <code>multiple.responses</code>
is <code>TRUE</code>.  This
argument allows for the parallelism assumption whereby the regression
coefficients for a variable is constrained to be equal over the <i>M</i>
linear/additive predictors.
If <code>parallel = TRUE</code> then the constraint is not applied to the
intercepts.
</p>
</td></tr>
<tr valign="top"><td><code>zero</code></td>
<td>

<p>An integer-valued vector specifying which linear/additive predictors
are modelled as intercepts only.  The values must be from the set
{1,2,...,<i>M</i>}, where <i>M</i> is the number of columns of the
matrix response.
See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information.
</p>
</td></tr>
<tr valign="top"><td><code>earg.link</code></td>
<td>

<p>Details at <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>bred</code></td>
<td>

<p>Details at <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code>.
Setting <code>bred = TRUE</code> should work for
multiple responses (<code>multiple.responses = TRUE</code>) and
all <span class="pkg">VGAM</span> link functions;
it has been tested for
<code><a href="logit.html">logit</a></code> only (and it gives similar
results to <span class="pkg">brglm</span> but not identical),
and further testing is required.
One result from fitting bias reduced binary regression
is that finite regression coefficients occur when
the data is separable (see example below).
Currently <code><a href="hdeff.html">hdeff.vglm</a></code> does not work when
<code>bred = TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is largely to
mimic <code><a href="../../stats/html/Binomial.html">binomial</a></code>,
however there are some differences.
</p>











<p>When used with <code><a href="cqo.html">cqo</a></code> and <code><a href="cao.html">cao</a></code>, it may be
preferable to use the <code><a href="cloglog.html">cloglog</a></code> link.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> (see <code><a href="vglmff-class.html">vglmff-class</a></code>).
The object is used by modelling functions such as
<code><a href="vglm.html">vglm</a></code>,
<code><a href="vgam.html">vgam</a></code>,
<code><a href="rrvglm.html">rrvglm</a></code>,
<code><a href="cqo.html">cqo</a></code>,
and <code><a href="cao.html">cao</a></code>.
</p>


<h3>Warning </h3>




<p>See the above note regarding <code>bred</code>.
</p>
<p>The maximum likelihood estimate will not exist if the data is
<em>completely separable</em> or <em>quasi-completely separable</em>.
See Chapter 10 of Altman et al. (2004) for more details,
and <span class="pkg">safeBinaryRegression</span>.
Yet to do: add a <code>sepcheck = TRUE</code>, say, argument to detect this
problem and give an appropriate warning.
</p>


<h3>Note</h3>

<p>If <code>multiple.responses</code> is <code>FALSE</code> (default) then
the response can be of one
of two formats:
a factor (first level taken as failure),
or a 2-column matrix (first column = successes) of counts.
The argument <code>weights</code> in the modelling function can
also be specified as any vector of positive values.
In general, 1 means success and 0 means failure
(to check, see the <code>y</code> slot of the fitted object).
Note that a general vector of proportions of success is no
longer accepted.
</p>
<p>The notation <i>M</i> is used to denote the number of linear/additive
predictors.
</p>
<p>If <code>multiple.responses</code> is <code>TRUE</code>, then the matrix response
can only be of one format: a matrix of 1's and 0's (1 = success).
</p>










<p>Fisher scoring is used. This can sometimes fail to converge by
oscillating between successive iterations (Ridout, 1990).
See the example below.
</p>


<h3>Author(s)</h3>

<p> Thomas W. Yee </p>


<h3>References</h3>

<p>McCullagh, P. and Nelder, J. A. (1989)
<em>Generalized Linear Models</em>, 2nd ed. London: Chapman &amp; Hall.
</p>
<p>Altman, M. and Gill, J. and McDonald, M. P. (2004)
<em>Numerical Issues in Statistical Computing for the Social
Scientist</em>, Hoboken, NJ, USA: Wiley-Interscience.
</p>
<p>Ridout, M. S. (1990)
Non-convergence of Fisher's method of scoring&mdash;a simple example.
<em>GLIM Newsletter</em>, 20(6).
</p>


<h3>See Also</h3>

<p><code><a href="hdeff.html">hdeff.vglm</a></code>,
<code><a href="Links.html">Links</a></code>,
<code><a href="rrvglm.html">rrvglm</a></code>,
<code><a href="cqo.html">cqo</a></code>,
<code><a href="cao.html">cao</a></code>,
<code><a href="betabinomial.html">betabinomial</a></code>,
<code><a href="posbinomial.html">posbinomial</a></code>,
<code><a href="zibinomial.html">zibinomial</a></code>,
<code><a href="double.expbinomial.html">double.expbinomial</a></code>,
<code><a href="seq2binomial.html">seq2binomial</a></code>,
<code><a href="amlbinomial.html">amlbinomial</a></code>,
<code><a href="simplex.html">simplex</a></code>,
<code><a href="../../stats/html/Binomial.html">binomial</a></code>,
<code><a href="simulate.vlm.html">simulate.vlm</a></code>,
<span class="pkg">safeBinaryRegression</span>,
<code><a href="residualsvglm.html">residualsvglm</a></code>.
</p>




<h3>Examples</h3>

<pre>
shunua &lt;- hunua[sort.list(with(hunua, altitude)), ]  # Sort by altitude
fit &lt;- vglm(agaaus ~ poly(altitude, 2), binomialff(link = cloglog),
            data = shunua)
## Not run: 
plot(agaaus ~ jitter(altitude), shunua, ylab = "Pr(Agaaus = 1)",
     main = "Presence/absence of Agathis australis", col = 4, las = 1)
with(shunua, lines(altitude, fitted(fit), col = "orange", lwd = 2)) 
## End(Not run)


# Fit two species simultaneously
fit2 &lt;- vgam(cbind(agaaus, kniexc) ~ s(altitude),
             binomialff(multiple.responses = TRUE), data = shunua)
## Not run: 
with(shunua, matplot(altitude, fitted(fit2), type = "l",
     main = "Two species response curves", las = 1)) 
## End(Not run)


# Shows that Fisher scoring can sometime fail. See Ridout (1990).
ridout &lt;- data.frame(v = c(1000, 100, 10), r = c(4, 3, 3), n = rep(5, 3))
(ridout &lt;- transform(ridout, logv = log(v)))
# The iterations oscillates between two local solutions:
glm.fail &lt;- glm(r / n ~ offset(logv) + 1, weight = n,
               binomial(link = 'cloglog'), ridout, trace = TRUE)
coef(glm.fail)
# vglm()'s half-stepping ensures the MLE of -5.4007 is obtained:
vglm.ok &lt;- vglm(cbind(r, n-r) ~ offset(logv) + 1,
               binomialff(link = cloglog), ridout, trace = TRUE)
coef(vglm.ok)


# Separable data
set.seed(123)
threshold &lt;- 0
bdata &lt;- data.frame(x2 = sort(rnorm(nn &lt;- 100)))
bdata &lt;- transform(bdata, y1 = ifelse(x2 &lt; threshold, 0, 1))
fit &lt;- vglm(y1 ~ x2, binomialff(bred = TRUE),
            data = bdata, criter = "coef", trace = TRUE)
coef(fit, matrix = TRUE)  # Finite!!
summary(fit)
## Not run:  plot(depvar(fit) ~ x2, data = bdata, col = "blue", las = 1)
lines(fitted(fit) ~ x2, data = bdata, col = "orange")
abline(v = threshold, col = "gray", lty = "dashed") 
## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-6 <a href="00Index.html">Index</a>]</div>
</body></html>
