<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Geometry Intersections</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for gIntersection {rgeos}"><tr><td>gIntersection {rgeos}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Geometry Intersections</h2>

<h3>Description</h3>

<p>Function for determining the intersection between the two given geometries</p>


<h3>Usage</h3>

<pre>
gIntersection(spgeom1, spgeom2, byid=FALSE, id=NULL, drop_not_poly,
 drop_lower_td=FALSE, unaryUnion_if_byid_false=TRUE, checkValidity=NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>spgeom1, spgeom2</code></td>
<td>
<p>sp objects as defined in package sp</p>
</td></tr>
<tr valign="top"><td><code>byid</code></td>
<td>
<p>Logical vector determining if the function should be applied across ids (TRUE) or the entire object (FALSE) for spgeom1 and spgeom2</p>
</td></tr>
<tr valign="top"><td><code>id</code></td>
<td>
<p>Character vector defining id labels for the resulting geometries, if unspecified returned geometries will be labeled based on their parent geometries' labels.</p>
</td></tr>
<tr valign="top"><td><code>drop_not_poly</code></td>
<td>
<p>deprecated argument, use drop_lower_td</p>
</td></tr>
<tr valign="top"><td><code>drop_lower_td</code></td>
<td>
<p>default FALSE; if TRUE, objects will be dropped from output GEOMETRYCOLLECTION objects to simplify output if their topological dimension is less than the minimum topological dinension of the input objects.</p>
</td></tr>
<tr valign="top"><td><code>unaryUnion_if_byid_false</code></td>
<td>
<p>default TRUE; if <code>byid</code> takes a FALSE in either position, the subgeometries are combined first to avoid possible topology exceptions (change in 0.3-13, previous behaviour did not combine subgeometries, and may be achieved by setting this argument FALSE</p>
</td></tr>
<tr valign="top"><td><code>checkValidity</code></td>
<td>
<p>default NULL, integer 0L (no action), 1L (check), 2L (check and try to buffer by zero distance to repair). If NULL, a value set to 0L for GEOS &lt; 3.7.2, 1L for GEOS &gt;= 3.7.2 is read from values assigned on load. Error meesages from GEOS do not say clearly which object fails if a topology exception is encountered. If this argument is &gt; 0L, <code>gIsValid</code> is run on each in turn</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns all spatial intersections as sp objects of the appropriate class. If the geometries do not intersect then an empty geometry is returned.</p>


<h3>Note</h3>

<p>Error messages from GEOS, in particular topology exceptions, report 0-based object order, so geom 0 is spgeom1, and geom 1 is spgeom2.</p>


<h3>Author(s)</h3>

<p>Roger Bivand &amp; Colin Rundel</p>


<h3>See Also</h3>

<p><code><a href="topo-bin-gDifference.html">gDifference</a></code>
<code><a href="topo-bin-gSymdifference.html">gSymdifference</a></code>
<code><a href="topo-bin-gUnion.html">gUnion</a></code>
</p>


<h3>Examples</h3>

<pre>
if (require(maptools)) {
xx &lt;- readShapeSpatial(system.file("shapes/fylk-val-ll.shp", package="maptools")[1],
 proj4string=CRS("+proj=longlat +datum=WGS84"))
bbxx &lt;- bbox(xx)
wdb_lines &lt;- system.file("share/wdb_borders_c.b", package="maptools")
xxx &lt;- Rgshhs(wdb_lines, xlim=bbxx[1,], ylim=bbxx[2,])$SP
res &lt;-gIntersection(xx, xxx)
plot(xx, axes=TRUE)
plot(xxx, lty=2, add=TRUE)
plot(res, add=TRUE, pch=16,col='red')
}
pol &lt;- readWKT(paste("POLYGON((-180 -20, -140 55, 10 0, -140 -60, -180 -20),",
 "(-150 -20, -100 -10, -110 20, -150 -20))"))
library(sp)
GT &lt;- GridTopology(c(-175, -85), c(10, 10), c(36, 18))
gr &lt;- as(as(SpatialGrid(GT), "SpatialPixels"), "SpatialPolygons")
try(res &lt;- gIntersection(pol, gr, byid=TRUE))
res &lt;- gIntersection(pol, gr, byid=TRUE, drop_lower_td=TRUE)
# Robert Hijmans difficult intersection case
load(system.file("test_cases/polys.RData", package="rgeos"))
try(res &lt;- gIntersection(a, b, byid=TRUE))
res &lt;- gIntersection(a, b, byid=TRUE, drop_lower_td=TRUE)
unlist(sapply(slot(res, "polygons"), function(p) sapply(slot(p, "Polygons"), slot, "area")))
# example from Pius Korner 2015-10-25
poly1 &lt;- SpatialPolygons(list(Polygons(list(Polygon(coords=matrix(c(0, 0, 2, 2, 0, 1, 1, 0),
 ncol=2, byrow=FALSE))), ID=c("a")), Polygons(list(Polygon(coords=matrix(c(0, 0, 2, 2, 2, 3, 3, 2),
 ncol=2, byrow=FALSE))), ID=c("b"))))
poly2 &lt;- SpatialPolygons(list(Polygons(list(Polygon(coords=matrix(c(0, 0, 2, 2,
 1, 1, 1, 3, 3, 0, 0, 2), ncol=2, byrow=FALSE))), ID=c("c"))))
plot(poly1, border="orange")
plot(poly2, border="blue", add=TRUE, lty=2, density=8, angle=30, col="blue")
gI &lt;- gIntersection(poly1, poly2, byid=TRUE, drop_lower_td=TRUE)
plot(gI, add=TRUE, border="red", lwd=3)
oT &lt;- get_RGEOS_polyThreshold()
oW &lt;- get_RGEOS_warnSlivers()
oD &lt;- get_RGEOS_dropSlivers()
set_RGEOS_polyThreshold(1e-3)
set_RGEOS_warnSlivers(TRUE)
res1 &lt;- gIntersection(a, b, byid=TRUE, drop_lower_td=TRUE)
unlist(sapply(slot(res1, "polygons"), function(p) sapply(slot(p, "Polygons"), slot, "area")))
set_RGEOS_dropSlivers(TRUE)
res2 &lt;- gIntersection(a, b, byid=TRUE, drop_lower_td=TRUE)
unlist(sapply(slot(res2, "polygons"), function(p) sapply(slot(p, "Polygons"), slot, "area")))
set_RGEOS_dropSlivers(FALSE)
oo &lt;- gUnaryUnion(res1, c(rep("1", 3), "2", "3", "4"), checkValidity=2L)
unlist(sapply(slot(oo, "polygons"), function(p) sapply(slot(p, "Polygons"), slot, "area")))
ooo &lt;- gIntersection(b, oo, byid=TRUE, checkValidity=2L)
gArea(ooo, byid=TRUE)
unlist(sapply(slot(ooo, "polygons"), function(p) sapply(slot(p, "Polygons"), slot, "area")))
set_RGEOS_dropSlivers(TRUE)
ooo &lt;- gIntersection(b, oo, byid=TRUE, checkValidity=2L)
gArea(ooo, byid=TRUE)
unlist(sapply(slot(ooo, "polygons"), function(p) sapply(slot(p, "Polygons"), slot, "area")))
set_RGEOS_polyThreshold(oT)
set_RGEOS_warnSlivers(oW)
set_RGEOS_dropSlivers(oD)
# see thread https://stat.ethz.ch/pipermail/r-sig-geo/2015-September/023468.html
Pol1=rbind(c(0,0),c(0,10),c(10,10),c(10,0),c(0,0))
Pol2=rbind(c(0,0),c(10,0),c(10,-10),c(0,-10),c(0,0))
library(sp)
Pols1=Polygons(list(Polygon(Pol1)),"Pols1")
Pols2=Polygons(list(Polygon(Pol2)),"Pols2")
MyLay=SpatialPolygons(list(Pols1,Pols2))
Pol1l=Pol1+0.5
Pol2l=Pol2+0.5
Pols1l=Polygons(list(Polygon(Pol1l)),"Pols1l")
Pols2l=Polygons(list(Polygon(Pol2l)),"Pols2l")
MyLayl=SpatialPolygons(list(Pols1l,Pols2l))
inter=gIntersection(MyLay, MyLayl)
plot(MyLay)
plot(MyLayl,add=TRUE)
plot(inter, add=TRUE, border="green")
try(gIntersection(MyLay, MyLayl, unaryUnion_if_byid_false=FALSE))
Pol1=rbind(c(0,0),c(0,1),c(1,1),c(1,0),c(0,0))
Pol2=rbind(c(0,0),c(1,0),c(1,-1),c(0,-1),c(0,0))
Pols1=Polygons(list(Polygon(Pol1)),"Pols1")
Pols2=Polygons(list(Polygon(Pol2)),"Pols2")
MyLay=SpatialPolygons(list(Pols1,Pols2))
Pol1l=Pol1+0.1
Pol2l=Pol2+0.1
Pols1l=Polygons(list(Polygon(Pol1l)),"Pols1l")
Pols2l=Polygons(list(Polygon(Pol2l)),"Pols2l")
MyLayl=SpatialPolygons(list(Pols1l,Pols2l))
inter=gIntersection(MyLay, MyLayl, unaryUnion_if_byid_false=FALSE)
gEquals(inter, MyLay)
inter1=gIntersection(MyLay, MyLayl, unaryUnion_if_byid_false=TRUE)
gEquals(inter1, MyLay)
gEquals(inter, inter1)
plot(MyLay, ylim=c(-1, 1.1))
plot(MyLayl, add=TRUE)
plot(inter, angle=45, density=10, add=TRUE)
plot(inter1, angle=135, density=10, add=TRUE)
inter2=gIntersection(MyLay, MyLayl)
gEquals(inter2, MyLay)
gEquals(inter1, inter2)
</pre>

<hr /><div style="text-align: center;">[Package <em>rgeos</em> version 0.5-2 <a href="00Index.html">Index</a>]</div>
</body></html>
